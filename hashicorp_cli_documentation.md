---
page_title: "hcp_aws_network_peering Resource - terraform-provider-hcp"
subcategory: "HashiCorp Virtual Networks"
description: |-
  The AWS network peering resource allows you to manage a network peering between an HVN and a peer AWS VPC.
---

# hcp_aws_network_peering (Resource)

The AWS network peering resource allows you to manage a network peering between an HVN and a peer AWS VPC.

## Example Usage

```terraform
provider "aws" {
  region = "us-west-2"
}

resource "hcp_hvn" "main" {
  hvn_id         = "main-hvn"
  cloud_provider = "aws"
  region         = "us-west-2"
  cidr_block     = "172.25.16.0/20"
}

resource "aws_vpc" "peer" {
  cidr_block = "172.31.0.0/16"
}

data "aws_arn" "peer" {
  arn = aws_vpc.peer.arn
}

resource "hcp_aws_network_peering" "dev" {
  hvn_id          = hcp_hvn.main.hvn_id
  peering_id      = "dev"
  peer_vpc_id     = aws_vpc.peer.id
  peer_account_id = aws_vpc.peer.owner_id
  peer_vpc_region = data.aws_arn.peer.region
}

resource "hcp_hvn_route" "main-to-dev" {
  hvn_link         = hcp_hvn.main.self_link
  hvn_route_id     = "main-to-dev"
  destination_cidr = "172.31.0.0/16"
  target_link      = hcp_aws_network_peering.dev.self_link
}

resource "aws_vpc_peering_connection_accepter" "peer" {
  vpc_peering_connection_id = hcp_aws_network_peering.dev.provider_peering_id
  auto_accept               = true
}
```

<!-- schema generated by tfplugindocs -->
## Schema

### Required

- `hvn_id` (String) The ID of the HashiCorp Virtual Network (HVN).
- `peer_account_id` (String) The account ID of the peer VPC in AWS.
- `peer_vpc_id` (String) The ID of the peer VPC in AWS.
- `peer_vpc_region` (String) The region of the peer VPC in AWS.
- `peering_id` (String) The ID of the network peering.

### Optional

- `project_id` (String) The ID of the HCP project where the network peering is located. Always matches the HVN's project.
If not specified, the project specified in the HCP Provider config block will be used, if configured.
If a project is not configured in the HCP Provider config block, the oldest project in the organization will be used.
- `timeouts` (Block, Optional) (see [below for nested schema](#nestedblock--timeouts))

### Read-Only

- `created_at` (String) The time that the network peering was created.
- `expires_at` (String) The time after which the network peering will be considered expired if it hasn't transitioned into `ACCEPTED` or `ACTIVE` state.
- `id` (String) The ID of this resource.
- `organization_id` (String) The ID of the HCP organization where the network peering is located. Always matches the HVN's organization.
- `provider_peering_id` (String) The peering connection ID used by AWS.
- `self_link` (String) A unique URL identifying the network peering.
- `state` (String) The state of the network peering.

<a id="nestedblock--timeouts"></a>
### Nested Schema for `timeouts`

Optional:

- `create` (String)
- `default` (String)
- `delete` (String)

## Import

Import is supported using the following syntax:

```shell
# Using an explicit project ID, the import ID is:
# {project_id}:{hvn_id}:{peering_id}
terraform import hcp_aws_network_peering.peer f709ec73-55d4-46d8-897d-816ebba28778:main-hvn:11eb60b3-d4ec-5eed-aacc-0242ac120015
# Using the provider-default project ID, the import ID is:
# {hvn_id}:{peering_id}
terraform import hcp_aws_network_peering.peer main-hvn:11eb60b3-d4ec-5eed-aacc-0242ac120015
```




# hcp_aws_transit_gateway_attachment (Resource)

~> **Security Notice:** This resource contains sensitive input. Please see this [list of recommendations](https://www.terraform.io/docs/language/state/sensitive-data.html) for storing sensitive information in Terraform.

The AWS transit gateway attachment resource allows you to manage a transit gateway attachment. The transit gateway attachment attaches an HVN to a user-owned transit gateway in AWS. Note that the HVN and transit gateway must be located in the same AWS region.

## Example Usage

```terraform
provider "aws" {
  region = "us-west-2"
}

resource "hcp_hvn" "main" {
  hvn_id         = "main-hvn"
  cloud_provider = "aws"
  region         = "us-west-2"
  cidr_block     = "172.25.16.0/20"
}

resource "aws_vpc" "example" {
  cidr_block = "172.31.0.0/16"
}

resource "aws_ec2_transit_gateway" "example" {
  tags = {
    Name = "example-tgw"
  }
}

resource "aws_ram_resource_share" "example" {
  name                      = "example-resource-share"
  allow_external_principals = true
}

resource "aws_ram_principal_association" "example" {
  resource_share_arn = aws_ram_resource_share.example.arn
  principal          = hcp_hvn.main.provider_account_id
}

resource "aws_ram_resource_association" "example" {
  resource_share_arn = aws_ram_resource_share.example.arn
  resource_arn       = aws_ec2_transit_gateway.example.arn
}

resource "hcp_aws_transit_gateway_attachment" "example" {
  depends_on = [
    aws_ram_principal_association.example,
    aws_ram_resource_association.example,
  ]

  hvn_id                        = hcp_hvn.main.hvn_id
  transit_gateway_attachment_id = "example-tgw-attachment"
  transit_gateway_id            = aws_ec2_transit_gateway.example.id
  resource_share_arn            = aws_ram_resource_share.example.arn
}

resource "hcp_hvn_route" "route" {
  hvn_link         = hcp_hvn.main.self_link
  hvn_route_id     = "hvn-to-tgw-attachment"
  destination_cidr = aws_vpc.example.cidr_block
  target_link      = hcp_aws_transit_gateway_attachment.example.self_link
}

resource "aws_ec2_transit_gateway_vpc_attachment_accepter" "example" {
  transit_gateway_attachment_id = hcp_aws_transit_gateway_attachment.example.provider_transit_gateway_attachment_id
}
```

<!-- schema generated by tfplugindocs -->
## Schema

### Required

- `hvn_id` (String) The ID of the HashiCorp Virtual Network (HVN).
- `resource_share_arn` (String, Sensitive) The Amazon Resource Name (ARN) of the Resource Share that is needed to grant HCP access to the transit gateway in AWS. The Resource Share should be associated with the HCP AWS account principal (see [aws_ram_principal_association](https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/ram_principal_association)) and the transit gateway resource (see [aws_ram_resource_association](https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/ram_resource_association))
- `transit_gateway_attachment_id` (String) The user-settable name of the transit gateway attachment in HCP.
- `transit_gateway_id` (String) The ID of the user-owned transit gateway in AWS. The AWS region of the transit gateway must match the HVN.

### Optional

- `project_id` (String) The ID of the HCP project where the transit gateway attachment is located." 
If not specified, the project specified in the HCP Provider config block will be used, if configured.
If a project is not configured in the HCP Provider config block, the oldest project in the organization will be used.
- `timeouts` (Block, Optional) (see [below for nested schema](#nestedblock--timeouts))

### Read-Only

- `created_at` (String) The time that the transit gateway attachment was created.
- `expires_at` (String) The time after which the transit gateway attachment will be considered expired if it hasn't transitioned into `ACCEPTED` or `ACTIVE` state.
- `id` (String) The ID of this resource.
- `organization_id` (String) The ID of the HCP organization where the transit gateway attachment is located. Always matches the HVN's organization.
- `provider_transit_gateway_attachment_id` (String) The transit gateway attachment ID used by AWS.
- `self_link` (String) A unique URL identifying the transit gateway attachment.
- `state` (String) The state of the transit gateway attachment.

<a id="nestedblock--timeouts"></a>
### Nested Schema for `timeouts`

Optional:

- `create` (String)
- `default` (String)
- `delete` (String)

## Import

-> **Note:** When importing a transit gateway attachment, you will want to configure a `lifecycle` configuration block with an `ignore_changes` argument including `resource_share_arn`. This is needed because its value is no longer retrievable after creation.

Import is supported using the following syntax:

```shell
# Using an explicit project ID, the import ID is:
# {project_id}:{hvn_id}:{transit_gateway_attachment_id}
terraform import hcp_aws_transit_gateway_attachment.example f709ec73-55d4-46d8-897d-816ebba28778:main-hvn:example-tgw-attachment
# Using the provider-default project ID, the import ID is:
# {hvn_id}:{transit_gateway_attachment_id}
terraform import hcp_aws_transit_gateway_attachment.example main-hvn:example-tgw-attachment
```




# hcp_azure_peering_connection (Resource)

The Azure peering connection resource allows you to manage a peering connection between an HVN and a peer Azure VNet.

## Example Usage

```terraform
resource "hcp_hvn" "hvn" {
  hvn_id         = "main-hvn"
  cloud_provider = "azure"
  region         = "westus2"
  cidr_block     = "172.25.16.0/20"
}

// This resource initially returns in a Pending state, because its application_id is required to complete acceptance of the connection.
resource "hcp_azure_peering_connection" "peer" {
  hvn_link                 = hcp_hvn.hvn.self_link
  peering_id               = "dev"
  peer_vnet_name           = azurerm_virtual_network.vnet.name
  peer_subscription_id     = azurerm_subscription.sub.subscription_id
  peer_tenant_id           = "<tenant UUID>"
  peer_resource_group_name = azurerm_resource_group.rg.name
  peer_vnet_region         = azurerm_virtual_network.vnet.location
}

// This data source is the same as the resource above, but waits for the connection to be Active before returning.
data "hcp_azure_peering_connection" "peer" {
  hvn_link              = hcp_hvn.hvn.self_link
  peering_id            = hcp_azure_peering_connection.peer.peering_id
  wait_for_active_state = true
}

// The route depends on the data source, rather than the resource, to ensure the peering is in an Active state.
resource "hcp_hvn_route" "route" {
  hvn_link         = hcp_hvn.hvn.self_link
  hvn_route_id     = "azure-route"
  destination_cidr = "172.31.0.0/16"
  target_link      = data.hcp_azure_peering_connection.peer.self_link
}

provider "azurerm" {
  features {}
}

provider "azuread" {}

data "azurerm_subscription" "sub" {
  subscription_id = "<subscription UUID>"
}

resource "azurerm_resource_group" "rg" {
  name     = "resource-group-test"
  location = "West US"
}

resource "azurerm_virtual_network" "vnet" {
  name                = "vnet-test"
  location            = azurerm_resource_group.rg.location
  resource_group_name = azurerm_resource_group.rg.name

  address_space = [
    "10.0.0.0/16"
  ]
}

resource "azuread_service_principal" "principal" {
  application_id = hcp_azure_peering_connection.peer.application_id
}

resource "azurerm_role_definition" "definition" {
  name  = "hcp-hvn-peering-access"
  scope = azurerm_virtual_network.vnet.id

  assignable_scopes = [
    azurerm_virtual_network.vnet.id
  ]

  permissions {
    actions = [
      "Microsoft.Network/virtualNetworks/peer/action",
      "Microsoft.Network/virtualNetworks/virtualNetworkPeerings/read",
      "Microsoft.Network/virtualNetworks/virtualNetworkPeerings/write"
    ]
  }
}

resource "azurerm_role_assignment" "assignment" {
  principal_id       = azuread_service_principal.principal.id
  scope              = azurerm_virtual_network.vnet.id
  role_definition_id = azurerm_role_definition.definition.role_definition_resource_id
}
```

<!-- schema generated by tfplugindocs -->
## Schema

### Required

- `hvn_link` (String) The `self_link` of the HashiCorp Virtual Network (HVN).
- `peer_resource_group_name` (String) The resource group name of the peer VNet in Azure.
- `peer_subscription_id` (String) The subscription ID of the peer VNet in Azure.
- `peer_tenant_id` (String) The tenant ID of the peer VNet in Azure.
- `peer_vnet_name` (String) The name of the peer VNet in Azure.
- `peer_vnet_region` (String) The region of the peer VNet in Azure.
- `peering_id` (String) The ID of the peering connection.

### Optional

- `allow_forwarded_traffic` (Boolean) Whether the forwarded traffic originating from the peered VNet is allowed in the HVN
- `timeouts` (Block, Optional) (see [below for nested schema](#nestedblock--timeouts))
- `use_remote_gateways` (Boolean) If the HVN should use the gateway of the peered VNet

### Read-Only

- `application_id` (String) The ID of the Azure application whose credentials are used to peer the HCP HVN's underlying VNet with the customer VNet.
- `azure_peering_id` (String) The peering connection ID used by Azure.
- `created_at` (String) The time that the peering connection was created.
- `expires_at` (String) The time after which the peering connection will be considered expired if it hasn't transitioned into `ACCEPTED` or `ACTIVE` state.
- `id` (String) The ID of this resource.
- `organization_id` (String) The ID of the HCP organization where the peering connection is located. Always matches the HVN's organization.
- `project_id` (String) The ID of the HCP project where the peering connection is located. Always matches the HVN's project.
- `self_link` (String) A unique URL identifying the peering connection.
- `state` (String) The state of the Azure peering connection.

<a id="nestedblock--timeouts"></a>
### Nested Schema for `timeouts`

Optional:

- `create` (String)
- `default` (String)
- `delete` (String)

## Import

Import is supported using the following syntax:

```shell
# Using an explicit project ID, the import ID is:
# {project_id}:{hvn_id}:{peering_id}
terraform import hcp_azure_peering_connection.peer f709ec73-55d4-46d8-897d-816ebba28778:main-hvn:199e7e96-4d5f-4456-91f3-b6cc71f1e561
# Using the provider-default project ID, the import ID is:
# {hvn_id}:{peering_id}
terraform import hcp_azure_peering_connection.peer main-hvn:199e7e96-4d5f-4456-91f3-b6cc71f1e561
```




# hcp_boundary_cluster (Resource)

This resource allows you to manage an HCP Boundary cluster

## Example Usage

```terraform
resource "hcp_boundary_cluster" "example" {
  cluster_id = "boundary-cluster"
  username   = "test-user"
  password   = "Password123!"
  maintenance_window_config {
    day          = "TUESDAY"
    start        = 2
    end          = 12
    upgrade_type = "SCHEDULED"
  }
  auth_token_time_to_live  = "36h0m0s"
  auth_token_time_to_stale = "12h0m0s"
}
```

<!-- schema generated by tfplugindocs -->
## Schema

### Required

- `cluster_id` (String) The ID of the Boundary cluster
- `password` (String, Sensitive) The password of the initial admin user. This must be at least 8 characters in length. Note that this may show up in logs, and it will be stored in the state file.
- `tier` (String) The tier that the HCP Boundary cluster will be provisioned as, 'Standard' or 'Plus'.
- `username` (String) The username of the initial admin user. This must be at least 3 characters in length, alphanumeric, hyphen, or period.

### Optional

- `auth_token_time_to_live` (String) The time to live for the auth token in golang's time.Duration string format.
- `auth_token_time_to_stale` (String) The time to stale for the auth token in golang's time.Duration string format.
- `maintenance_window_config` (Block List, Max: 1) The maintenance window configuration for when cluster upgrades can take place. (see [below for nested schema](#nestedblock--maintenance_window_config))
- `project_id` (String) The ID of the HCP project where the Boundary cluster is located.
If not specified, the project specified in the HCP Provider config block will be used, if configured.
If a project is not configured in the HCP Provider config block, the oldest project in the organization will be used.
- `timeouts` (Block, Optional) (see [below for nested schema](#nestedblock--timeouts))

### Read-Only

- `cluster_url` (String) A unique URL identifying the Boundary cluster.
- `created_at` (String) The time that the Boundary cluster was created.
- `id` (String) The ID of this resource.
- `state` (String) The state of the Boundary cluster.
- `version` (String) The version of the Boundary cluster.

<a id="nestedblock--maintenance_window_config"></a>
### Nested Schema for `maintenance_window_config`

Optional:

- `day` (String) The maintenance day of the week for scheduled upgrades. Valid options for maintenance window day - `MONDAY`, `TUESDAY`, `WEDNESDAY`, `THURSDAY`, `FRIDAY`, `SATURDAY`, `SUNDAY`
- `end` (Number) The end time which upgrades can be performed. Uses 24H clock and must be in UTC time zone. Valid options include - 1 to 24 (inclusive)
- `start` (Number) The start time which upgrades can be performed. Uses 24H clock and must be in UTC time zone. Valid options include - 0 to 23 (inclusive)
- `upgrade_type` (String) The upgrade type for the cluster. Valid options for upgrade type - `AUTOMATIC`, `SCHEDULED`


<a id="nestedblock--timeouts"></a>
### Nested Schema for `timeouts`

Optional:

- `create` (String)
- `default` (String)
- `delete` (String)

## Import

Import is supported using the following syntax:

```shell
# Using an explicit project ID, the import ID is:
# {project_id}:{cluster_id}
terraform import hcp_boundary_cluster.example f709ec73-55d4-46d8-897d-816ebba28778:boundary-cluster
# Using the provider-default project ID, the import ID is:
# {cluster_id}
terraform import hcp_boundary_cluster.example boundary-cluster
```




# hcp_consul_agent_helm_config (Data Source)

The Consul agent Helm config data source provides Helm values for a Consul agent running in Kubernetes.

## Example Usage

```terraform
data "hcp_consul_agent_helm_config" "example" {
  cluster_id          = var.cluster_id
  kubernetes_endpoint = var.kubernetes_endpoint
}
```

<!-- schema generated by tfplugindocs -->
## Schema

### Required

- `cluster_id` (String) The ID of the HCP Consul cluster.
- `kubernetes_endpoint` (String) The FQDN for the Kubernetes API.

### Optional

- `expose_gossip_ports` (Boolean) Denotes that the gossip ports should be exposed.
- `project_id` (String) The ID of the HCP project where the HCP Consul cluster is located.
If not specified, the project specified in the HCP Provider config block will be used, if configured.
If a project is not configured in the HCP Provider config block, the oldest project in the organization will be used.
- `timeouts` (Block, Optional) (see [below for nested schema](#nestedblock--timeouts))

### Read-Only

- `config` (String) The agent Helm config.
- `id` (String) The ID of this resource.

<a id="nestedblock--timeouts"></a>
### Nested Schema for `timeouts`

Optional:

- `default` (String)




# hcp_consul_agent_kubernetes_secret (Data Source)

The agent config Kubernetes secret data source provides Consul agents running in Kubernetes the configuration needed to connect to the Consul cluster.

## Example Usage

```terraform
data "hcp_consul_agent_kubernetes_secret" "test" {
  cluster_id = var.cluster_id
}
```

<!-- schema generated by tfplugindocs -->
## Schema

### Required

- `cluster_id` (String) The ID of the HCP Consul cluster.

### Optional

- `project_id` (String) The ID of the HCP project where the HCP Consul cluster is located.
If not specified, the project specified in the HCP Provider config block will be used, if configured.
If a project is not configured in the HCP Provider config block, the oldest project in the organization will be used.
- `timeouts` (Block, Optional) (see [below for nested schema](#nestedblock--timeouts))

### Read-Only

- `id` (String) The ID of this resource.
- `secret` (String) The Consul agent configuration in the format of a Kubernetes secret (YAML).

<a id="nestedblock--timeouts"></a>
### Nested Schema for `timeouts`

Optional:

- `default` (String)




# hcp_consul_cluster (Resource)

Consul on Azure is available. See the [Get started with end-to-end deployment configuration](https://developer.hashicorp.com/consul/tutorials/cloud-deploy-automation/consul-end-to-end-overview) tutorial.
The Consul cluster resource allows you to manage an HCP Consul cluster.

## Example Usage

```terraform
resource "hcp_hvn" "example" {
  hvn_id         = "hvn"
  cloud_provider = "aws"
  region         = "us-west-2"
  cidr_block     = "172.25.16.0/20"
}

resource "hcp_consul_cluster" "example" {
  cluster_id = "consul-cluster"
  hvn_id     = hcp_hvn.example.hvn_id
  tier       = "development"
}
```

<!-- schema generated by tfplugindocs -->
## Schema

### Required

- `cluster_id` (String) The ID of the HCP Consul cluster.
- `hvn_id` (String) The ID of the HVN this HCP Consul cluster is associated to.
- `tier` (String) The tier that the HCP Consul cluster will be provisioned as.  Only `development`, `standard`, `plus`, and `premium` are available at this time. See [pricing information](https://www.hashicorp.com/products/consul/pricing).

### Optional

- `auto_hvn_to_hvn_peering` (Boolean) Enables automatic HVN to HVN peering when creating a secondary cluster in a federation. The alternative to using the auto-accept feature is to create an [`hcp_hvn_peering_connection`](hvn_peering_connection.md) resource that explicitly defines the HVN resources that are allowed to communicate with each other.
- `connect_enabled` (Boolean) Denotes the Consul connect feature should be enabled for this cluster.  Default to true.
- `datacenter` (String) The Consul data center name of the cluster. If not specified, it is defaulted to the value of `cluster_id`.
- `ip_allowlist` (Block List, Max: 3) Allowed IPV4 address ranges (CIDRs) for inbound traffic. Each entry must be a unique CIDR. Maximum 3 CIDRS supported at this time. (see [below for nested schema](#nestedblock--ip_allowlist))
- `min_consul_version` (String) The minimum Consul patch version of the cluster. Allows only the rightmost version component to increment (E.g: `1.13.0` will allow installation of `1.13.2` and `1.13.3` etc., but not `1.14.0`). If not specified, it is defaulted to the version that is currently recommended by HCP.
- `primary_link` (String) The `self_link` of the HCP Consul cluster which is the primary in the federation setup with this HCP Consul cluster. If not specified, it is a standalone cluster.
- `project_id` (String) The ID of the HCP project where the HCP Consul cluster is located.
If not specified, the project specified in the HCP Provider config block will be used, if configured.
If a project is not configured in the HCP Provider config block, the oldest project in the organization will be used.
- `public_endpoint` (Boolean) Denotes that the cluster has a public endpoint for the Consul UI. Defaults to false.
- `size` (String) The t-shirt size representation of each server VM that this Consul cluster is provisioned with. Valid option for development tier - `x_small`. Valid options for other tiers - `small`, `medium`, `large`. For more details - https://cloud.hashicorp.com/pricing/consul. Upgrading the size of a cluster after creation is allowed.
- `timeouts` (Block, Optional) (see [below for nested schema](#nestedblock--timeouts))

### Read-Only

- `cloud_provider` (String) The provider where the HCP Consul cluster is located.
- `consul_automatic_upgrades` (Boolean) Denotes that automatic Consul upgrades are enabled.
- `consul_ca_file` (String) The cluster CA file encoded as a Base64 string.
- `consul_config_file` (String) The cluster config encoded as a Base64 string.
- `consul_private_endpoint_url` (String) The private URL for the Consul UI.
- `consul_public_endpoint_url` (String) The public URL for the Consul UI. This will be empty if `public_endpoint` is `false`.
- `consul_root_token_accessor_id` (String) The accessor ID of the root ACL token that is generated upon cluster creation.
- `consul_root_token_secret_id` (String, Sensitive) The secret ID of the root ACL token that is generated upon cluster creation.
- `consul_snapshot_interval` (String) The Consul snapshot interval.
- `consul_snapshot_retention` (String) The retention policy for Consul snapshots.
- `consul_version` (String) The Consul version of the cluster.
- `id` (String) The ID of this resource.
- `organization_id` (String) The ID of the organization this HCP Consul cluster is located in.
- `region` (String) The region where the HCP Consul cluster is located.
- `scale` (Number) The number of Consul server nodes in the cluster.
- `self_link` (String) A unique URL identifying the HCP Consul cluster.
- `state` (String) The state of the HCP Consul cluster.

<a id="nestedblock--ip_allowlist"></a>
### Nested Schema for `ip_allowlist`

Required:

- `address` (String) IP address range in CIDR notation.

Optional:

- `description` (String) Description to help identify source (maximum 255 chars).


<a id="nestedblock--timeouts"></a>
### Nested Schema for `timeouts`

Optional:

- `create` (String)
- `default` (String)
- `delete` (String)
- `update` (String)

## Import

Import is supported using the following syntax:

```shell
# Using an explicit project ID, the import ID is:
# {project_id}:{cluster_id}
terraform import hcp_consul_cluster.example f709ec73-55d4-46d8-897d-816ebba28778:consul-cluster
# Using the provider-default project ID, the import ID is:
# {cluster_id}
terraform import hcp_consul_cluster.example consul-cluster
```




# hcp_consul_cluster_root_token (Resource)

~> **Security Notice:** Please see this [list of recommendations](https://www.terraform.io/docs/language/state/sensitive-data.html) for storing sensitive information in Terraform.

The cluster root token resource is the token used to bootstrap the cluster's ACL system. You can also generate this root token from the HCP Consul UI.

## Example Usage

```terraform
resource "hcp_consul_cluster_root_token" "example" {
  cluster_id = "consul-cluster"
}
```

<!-- schema generated by tfplugindocs -->
## Schema

### Required

- `cluster_id` (String) The ID of the HCP Consul cluster.

### Optional

- `project_id` (String) The ID of the HCP project where the HCP Consul cluster is located.
If not specified, the project specified in the HCP Provider config block will be used, if configured.
If a project is not configured in the HCP Provider config block, the oldest project in the organization will be used.
- `timeouts` (Block, Optional) (see [below for nested schema](#nestedblock--timeouts))

### Read-Only

- `accessor_id` (String) The accessor ID of the root ACL token.
- `id` (String) The ID of this resource.
- `kubernetes_secret` (String, Sensitive) The root ACL token Base64 encoded in a Kubernetes secret.
- `secret_id` (String, Sensitive) The secret ID of the root ACL token.

<a id="nestedblock--timeouts"></a>
### Nested Schema for `timeouts`

Optional:

- `default` (String)




# hcp_consul_snapshot (Resource)

The Consul snapshot resource allows users to manage Consul snapshots of an HCP Consul cluster. Snapshots currently have a retention policy of 30 days.

## Example Usage

```terraform
// Note: Snapshots currently have a retention policy of 30 days. After that time, any Terraform
// state refresh will note that a new snapshot resource will be created.
resource "hcp_consul_snapshot" "example" {
  cluster_id    = "consul-cluster"
  snapshot_name = "my-snapshot"
}
```

<!-- schema generated by tfplugindocs -->
## Schema

### Required

- `cluster_id` (String) The ID of the HCP Consul cluster.
- `snapshot_name` (String) The name of the snapshot.

### Optional

- `project_id` (String) The ID of the HCP project where the HCP Consul cluster is located.
If not specified, the project specified in the HCP Provider config block will be used, if configured.
If a project is not configured in the HCP Provider config block, the oldest project in the organization will be used.
- `timeouts` (Block, Optional) (see [below for nested schema](#nestedblock--timeouts))

### Read-Only

- `consul_version` (String) The version of Consul at the time of snapshot creation.
- `id` (String) The ID of this resource.
- `organization_id` (String) The ID of the HCP organization where the project the HCP Consul cluster is located.
- `restored_at` (String) Timestamp of when the snapshot was restored. If the snapshot has not been restored, this field will be blank.
- `size` (Number) The size of the snapshot in bytes.
- `snapshot_id` (String) The ID of the Consul snapshot
- `state` (String) The state of an HCP Consul snapshot.

<a id="nestedblock--timeouts"></a>
### Nested Schema for `timeouts`

Optional:

- `create` (String)
- `default` (String)
- `delete` (String)
- `update` (String)




# hcp_consul_versions (Data Source)

The Consul versions data source provides the Consul versions supported by HCP.

## Example Usage

```terraform
data "hcp_consul_versions" "default" {}
```

<!-- schema generated by tfplugindocs -->
## Schema

### Optional

- `timeouts` (Block, Optional) (see [below for nested schema](#nestedblock--timeouts))

### Read-Only

- `available` (List of String) The Consul versions available on HCP.
- `id` (String) The ID of this resource.
- `preview` (List of String) The preview versions of Consul available on HCP.
- `recommended` (String) The recommended Consul version for HCP clusters.

<a id="nestedblock--timeouts"></a>
### Nested Schema for `timeouts`

Optional:

- `default` (String)




# Federation with Auto HVN Peering

Once you have a HCP Consul cluster, you can create a new Consul cluster to federate with the existing one.
By providing `auto_hvn_to_hvn_peering` as a parameter on the secondary cluster, the HVNs are being peered
automatically ensuring full connectivity. This parameter only ever has to be provided on secondary clusters.

This example uses the `development` tier. There are restrictions for federating clusters, depending on the tier:

* `development`: allows multi-region and single-region federation with up to two secondary clusters
* `standard`: allows single-region federation without restrictions of the number of secondary clusters
* `plus`: allows multi-region federation without restrictions of the number of secondary clusters

Keep in mind that the account wide cluster limit applies to federation as well.

```terraform
resource "hcp_hvn" "primary" {
  hvn_id         = var.primary_hvn_id
  cloud_provider = var.cloud_provider
  region         = var.primary_region
}

resource "hcp_hvn" "secondary" {
  hvn_id         = var.secondary_hvn_id
  cloud_provider = var.cloud_provider
  region         = var.secondary_region
}

resource "hcp_consul_cluster" "primary" {
  hvn_id     = hcp_hvn.primary.hvn_id
  cluster_id = var.primary_cluster_id
  tier       = "development"
}

resource "hcp_consul_cluster" "secondary" {
  hvn_id                  = hcp_hvn.secondary.hvn_id
  cluster_id              = var.secondary_cluster_id
  tier                    = "development"
  primary_link            = hcp_consul_cluster.primary.self_link
  auto_hvn_to_hvn_peering = true
}
```




# Create a new Consul ACL root token

Creating a new root token is useful if your HCP Consul cluster has been imported into Terraform
or is managed outside of Terraform. It is important to note that when creating a new root token,
the existing root token will be invalidated.

```terraform
resource "hcp_hvn" "example" {
  hvn_id         = var.hvn_id
  cloud_provider = "aws"
  region         = "us-west-2"
}

// The root_token_accessor_id and root_token_secret_id properties will
// no longer be valid after the new root token is created below
resource "hcp_consul_cluster" "example" {
  hvn_id     = hcp_hvn.example.hvn_id
  cluster_id = var.cluster_id
  tier       = "development"
}

// Create a new ACL root token
resource "hcp_consul_cluster_root_token" "example" {
  cluster_id = hcp_consul_cluster.example.id
}
```

The secret ID of this root token can be used to configure the Consul provider.

```
provider "consul" {
  address    = "example.consul.io:80"
  token      = hcp_consul_cluster_root_token.example.secret_id
}
```




# Create Consul cluster snapshots

The snapshot resource allows users to manage Consul snapshots of an HCP cluster. Snapshots currently have a retention policy of 30 days.

Restoring snapshots via Terraform is not supported.  If you would like to restore a snapshot for your Consul cluster, navigate to the snapshots page via the HCP UI.

This can be done by navigating from the Consul list page to the cluster detail page and then in turn the snapshots tab within that view.
```terraform
resource "hcp_hvn" "example" {
  hvn_id         = var.hvn_id
  cloud_provider = var.cloud_provider
  region         = var.region
}

resource "hcp_consul_cluster" "example" {
  hvn_id     = hcp_hvn.example.hvn_id
  cluster_id = var.cluster_id
  tier       = "development"
}

resource "hcp_consul_snapshot" "example" {
  cluster_id    = hcp_consul_cluster.example.cluster_id
  snapshot_name = var.snapshot_name
}
```




# hcp_group (Resource)

The group resource manages a HCP Group.

The user or service account that is running Terraform when creating an `hcp_group` resource must have `roles/admin` on the parent resource; either the project or organization.

## Example Usage

```terraform
resource "hcp_group" "example" {
  display_name = "example-group"
  description  = "My new group!"
}
```

<!-- schema generated by tfplugindocs -->
## Schema

### Required

- `display_name` (String) The group's display_name - maximum length of 50 characters

### Optional

- `description` (String) The group's description - maximum length of 300 characters

### Read-Only

- `resource_id` (String) The group's unique identifier
- `resource_name` (String) The group's resource name in the format `iam/organization/<organization_id>/group/<name>`

## Import

Import is supported using the following syntax:

```shell
# Group can be imported by specifying the group resource name
terraform import hcp_group.example "iam/organization/org_id/group/group-name"
```




# hcp_group_iam_binding (Resource)

Updates the group's IAM policy to bind a role to a new member. Existing bindings are preserved.

~> **Note:** `hcp_group_iam_policy` can not be used in conjunction with
`hcp_group_iam_binding`.

## Example Usage

```terraform
# Fetch a user from HCP
data "hcp_user_principal" "example" {
  email = "user@example.com"
}

# Lookup an existing group in HCP
data "hcp_group" "example" {
  resource_name = "group-name"
}

# Add members to the group
resource "hcp_group_members" "example" {
  group = data.hcp_group.example.resource_name
  members = [
    data.hcp_user_principal.example.user_id
  ]
}

# Add an IAM binding to a group
resource "hcp_group_iam_binding" "example" {
  name         = data.hcp_group.example.resource_name
  principal_id = data.hcp_user_principal.example.user_id
  role         = "roles/iam.group-manager"
}
```

<!-- schema generated by tfplugindocs -->
## Schema

### Required

- `name` (String) The group's resource name in format `iam/organization/<organization_id>/group/<group_name>`. The shortened `<group_name>` version can be used for input.
- `principal_id` (String) The principal to bind to the given role.
- `role` (String) The role name to bind to the given principal.




# hcp_group_iam_policy (Resource)

Sets the group's IAM policy and replaces any existing policy.

~> **Note:** `hcp_group_iam_policy` can not be used in conjunction with
`hcp_group_iam_binding`.

## Example Usage

```terraform
# Fetch a user from HCP
data "hcp_user_principal" "example" {
  email = "user@example.com"
}

# Lookup an existing group in HCP
data "hcp_group" "example" {
  resource_name = "group-name"
}

# Add members to the group
resource "hcp_group_members" "example" {
  group = data.hcp_group.example.resource_name
  members = [
    data.hcp_user_principal.example.user_id
  ]
}

# Create an IAM policy for a group using the group manager role
data "hcp_iam_policy" "example" {
  bindings = [
    {
      role = "roles/iam.group-manager"
      principals = [
        data.hcp_user_principal.example.user_id,
      ]
    },
  ]
}

# Set the IAM policy on a group
resource "hcp_group_iam_policy" "example" {
  name        = data.hcp_group.example.resource_name
  policy_data = data.hcp_iam_policy.example.policy_data
}
```

<!-- schema generated by tfplugindocs -->
## Schema

### Required

- `name` (String) The group's resource name in format `iam/organization/<organization_id>/group/<group_name>`. The shortened `<group_name>` version can be used for input.
- `policy_data` (String) The policy to apply.

### Read-Only

- `etag` (String) The etag captures the existing state of the policy.

## Import

Import is supported using the following syntax:

```shell
# A Group's IAM Policy can be imported by specifying the group's resource name
terraform import hcp_group_iam_policy.example existing-group
```




# hcp_group_members (Resource)

The group members resource manages the members of an HCP Group.

The user or service account that is running Terraform when creating an `hcp_group_members` resource must have `roles/admin` on the organization.

## Example Usage

```terraform
resource "hcp_group_members" "example" {
  group = hcp_group.example.resource_name
  members = [
    hcp_user_principal.example1.user_id,
    hcp_user_principal.example2.user_id,
  ]
}
```

<!-- schema generated by tfplugindocs -->
## Schema

### Required

- `group` (String) The group's resource name in the format `iam/organization/<organization_id>/group/<name>`
- `members` (List of String) A list of user principal IDs to add to the group.

## Import

Import is supported using the following syntax:

```shell
# Group Members can be imported by specifying the group resource name
terraform import hcp_group_members.example "iam/organization/org_id/group/group-name"
```




# hcp_hvn (Resource)

The HVN resource allows you to manage a HashiCorp Virtual Network in HCP.

We recommend the following when selecting the CIDR block of an HVN:

- The CIDR block value must be a private IPv4 CIDR block within the [RFC1918](https://datatracker.ietf.org/doc/html/rfc1918) address space (10.*.*.*, 192.168.*.*, 172.[16-31].*.*).

- The CIDR block value must be the first IP address of the desired CIDR block. The helper `cidrsubnet("172.16.1.1/24", 0, 0)` will specify the first address of the CIDR block in the first argument.

- The CIDR block value must end between /16 and /25.

- If the CIDR block values for your HCP HVN and your cloud provider’s virtual network overlap you will not be able to establish a connection. The following are default CIDR block values to be aware of: HCP HVN (172.25.16.0/20), AWS VPC (172.31.0.0/16), and Azure VNet (172.29.0.0/24). Avoid creating overlapping networks.

- If you’re creating a HVN for use in production it's recommended that you specify a CIDR block value that does not overlap with the other HVNs already created in your organization. You will not be able to connect two HVNs with overlapping CIDR block values.

## Example Usage

```terraform
resource "hcp_hvn" "example" {
  hvn_id         = "main-hvn"
  cloud_provider = "aws"
  region         = "us-west-2"
  cidr_block     = "172.25.16.0/20"
}
```

<!-- schema generated by tfplugindocs -->
## Schema

### Required

- `cloud_provider` (String) The provider where the HVN is located. The provider 'aws' is generally available and 'azure' is in public beta.
- `hvn_id` (String) The ID of the HashiCorp Virtual Network (HVN).
- `region` (String) The region where the HVN is located.

### Optional

- `cidr_block` (String) The CIDR range of the HVN. If this is not provided, the service will provide a default value.
- `project_id` (String) The ID of the HCP project where the HVN is located.
If not specified, the project specified in the HCP Provider config block will be used, if configured.
If a project is not configured in the HCP Provider config block, the oldest project in the organization will be used.
- `timeouts` (Block, Optional) (see [below for nested schema](#nestedblock--timeouts))

### Read-Only

- `created_at` (String) The time that the HVN was created.
- `id` (String) The ID of this resource.
- `organization_id` (String) The ID of the HCP organization where the HVN is located.
- `provider_account_id` (String) The provider account ID where the HVN is located.
- `self_link` (String) A unique URL identifying the HVN.
- `state` (String) The state of the HVN.

<a id="nestedblock--timeouts"></a>
### Nested Schema for `timeouts`

Optional:

- `create` (String)
- `default` (String)
- `delete` (String)

## Import

Import is supported using the following syntax:

```shell
# Using an explicit project ID, the import ID is:
# {project_id}:{hvn_id}
terraform import hcp_hvn.example f709ec73-55d4-46d8-897d-816ebba28778:main-hvn
# Using the provider-default project ID, the import ID is:
# {hvn_id}
terraform import hcp_hvn.example main-hvn
```




# hcp_hvn_peering_connection (Resource)

The HVN peering connection resource allows you to manage a peering connection between HVNs.

## Example Usage

```terraform
resource "hcp_hvn" "hvn_1" {
  hvn_id         = "hvn-1"
  cloud_provider = "aws"
  region         = "us-west-2"
  cidr_block     = "172.25.16.0/20"
}

resource "hcp_hvn" "hvn_2" {
  hvn_id         = "hvn-2"
  cloud_provider = "aws"
  region         = "us-west-2"
  cidr_block     = "172.18.16.0/20"
}

resource "hcp_hvn_peering_connection" "peer_1" {
  hvn_1 = hcp_hvn.hvn_1.self_link
  hvn_2 = hcp_hvn.hvn_2.self_link
}
```

<!-- schema generated by tfplugindocs -->
## Schema

### Required

- `hvn_1` (String) The unique URL of one of the HVNs being peered.
- `hvn_2` (String) The unique URL of one of the HVNs being peered.

### Optional

- `project_id` (String, Deprecated) The ID of the HCP project where HVN peering connection is located. Always matches hvn_1's project ID. Setting this attribute is deprecated, but it will remain usable in read-only form.
- `timeouts` (Block, Optional) (see [below for nested schema](#nestedblock--timeouts))

### Read-Only

- `created_at` (String) The time that the peering connection was created.
- `expires_at` (String) The time after which the peering connection will be considered expired if it hasn't transitioned into `ACCEPTED` or `ACTIVE` state.
- `id` (String) The ID of this resource.
- `organization_id` (String) The ID of the HCP organization where the peering connection is located. Always matches both HVNs' organization ID.
- `peering_id` (String) The ID of the peering connection.
- `self_link` (String) A unique URL identifying the peering connection
- `state` (String) The state of the HVN peering connection.

<a id="nestedblock--timeouts"></a>
### Nested Schema for `timeouts`

Optional:

- `create` (String)
- `default` (String)
- `delete` (String)

## Import

Import is supported using the following syntax:

```shell
# Only the first HVN ID is required (hvn_1_id), HVN 2 will be populated after import.

# Using an explicit project ID, the import ID is:
# {project_id}:{hvn_1_id}:{peering_id}
terraform import hcp_hvn_peering_connection.peer_1 f709ec73-55d4-46d8-897d-816ebba28778:hvn-1:peer-1
# Using the provider-default project ID, the import ID is:
# {hvn_1_id}:{peering_id}
terraform import hcp_hvn_peering_connection.peer_1 hvn-1:peer-1
```




# hcp_hvn_route (Resource)

~> **Migration Required:** The release of HVN Routes in v0.7.0 includes breaking changes that affect `hcp_aws_network_peering` and `hcp_aws_transit_gateway_attachment`. [This guide](https://registry.terraform.io/providers/hashicorp/hcp/latest/docs/guides/hvn-route-migration-guide) walks through how to migrate to the new resource syntax.
Please pin to the previous version to avoid disruption until you are ready to migrate.

-> **Note:** The `destination_cidr` value must be an IPv4 CIDR block within the [RFC1918](https://datatracker.ietf.org/doc/html/rfc1918) private address space (10.*.*.*, 192.168.*.*, 172.[16-31].*.*) **or**
the [RFC6598](https://datatracker.ietf.org/doc/html/rfc6598) shared address space (100.64.*.*).

The HVN route resource allows you to manage an HVN route.

## Example Usage

```terraform
provider "aws" {
  region = "us-west-2"
}

resource "hcp_hvn" "main" {
  hvn_id         = "main-hvn"
  cloud_provider = "aws"
  region         = "us-west-2"
  cidr_block     = "172.25.16.0/20"
}

// Creating a peering and a route for it.
resource "aws_vpc" "peer" {
  cidr_block = "192.168.0.0/20"
}

resource "hcp_aws_network_peering" "example" {
  peering_id      = "peer-example"
  hvn_id          = hcp_hvn.main.hvn_id
  peer_vpc_id     = aws_vpc.peer.id
  peer_account_id = aws_vpc.peer.owner_id
  peer_vpc_region = "us-west-2"
}

resource "aws_vpc_peering_connection_accepter" "peer" {
  vpc_peering_connection_id = hcp_aws_network_peering.example.provider_peering_id
  auto_accept               = true
}

resource "hcp_hvn_route" "example-peering-route" {
  hvn_link         = hcp_hvn.main.self_link
  hvn_route_id     = "peering-route"
  destination_cidr = aws_vpc.peer.cidr_block
  target_link      = hcp_aws_network_peering.example.self_link
}
```

<!-- schema generated by tfplugindocs -->
## Schema

### Required

- `destination_cidr` (String) The destination CIDR of the HVN route.
- `hvn_link` (String) The `self_link` of the HashiCorp Virtual Network (HVN).
- `hvn_route_id` (String) The ID of the HVN route.
- `target_link` (String) A unique URL identifying the target of the HVN route. Examples of the target: [`aws_network_peering`](aws_network_peering.md), [`aws_transit_gateway_attachment`](aws_transit_gateway_attachment.md)

### Optional

- `azure_config` (Block List, Max: 1) The Azure configuration for routing. (see [below for nested schema](#nestedblock--azure_config))
- `project_id` (String, Deprecated) The ID of the HCP project where the HVN route is located. Always matches the project ID in `hvn_link`. Setting this attribute is deprecated, but it will remain usable in read-only form.
- `timeouts` (Block, Optional) (see [below for nested schema](#nestedblock--timeouts))

### Read-Only

- `created_at` (String) The time that the HVN route was created.
- `id` (String) The ID of this resource.
- `self_link` (String) A unique URL identifying the HVN route.
- `state` (String) The state of the HVN route.

<a id="nestedblock--azure_config"></a>
### Nested Schema for `azure_config`

Required:

- `next_hop_type` (String) The type of Azure hop the packet should be sent to. Valid options for Next Hop Type - `VIRTUAL_APPLIANCE` or `VIRTUAL_NETWORK_GATEWAY`

Optional:

- `next_hop_ip_address` (String) Contains the IP address packets should be forwarded to. Next hop values are only allowed in routes where the next hop type is VIRTUAL_APPLIANCE.


<a id="nestedblock--timeouts"></a>
### Nested Schema for `timeouts`

Optional:

- `create` (String)
- `default` (String)
- `delete` (String)

## Import

Import is supported using the following syntax:

```shell
# Using an explicit project ID, the import ID is:
# {project_id}:{hvn_id}:{hvn_route_id}
terraform import hcp_hvn_route.example f709ec73-55d4-46d8-897d-816ebba28778:main-hvn:example-hvn-route
# Using the provider-default project ID, the import ID is:
# {hvn_id}:{hvn_route_id}
terraform import hcp_hvn_route.example main-hvn:example-hvn-route
```




# Introducing HVN routes

The HVN route is a new resource that belongs to an HVN. It contains a CIDR block and targets a networking connection:
either a peering or transit gateway attachment.

HVN routes provide a general view on how an HVN's traffic is routed across all networking connections and create a flexible way of managing these routing rules.

## Migrating existing peerings and transit gateway attachments

There are two ways to migrate existing peerings and transit gateway attachments managed by Terraform:

 1. Recreate Resources with Updated Schema
    * This option is quicker but will result in downtime and possible data loss. Best for test environments. Will allow you to specify human-readable ids for the resources.
    * Comment out all `hcp_aws_network_peering` and `hcp_aws_transit_gateway_attachment` resources.
    * Run `terraform apply` to destroy currently existing connections.
    * Uncomment and update all `hcp_aws_network_peering` and `hcp_aws_transit_gateway_attachment` resource definitions to match the new schema.
    * Add corresponding `hcp_hvn_route` resources for each CIDR targeting corresponding peering connections or transit gateway attachment.
    * Run `terraform apply` to recreate connections.

 2. Re-Import with Updated Syntax:
    * This option allows you to avoid downtime or data loss.
    * Update any `hcp_aws_network_peering` and `hcp_aws_transit_gateway_attachment` resource definitions to match the new schema. All values needed can be found on the details pages of Peerings and TGW attachment in the HCP Portal.
    * Add corresponding `hcp_hvn_route` resources for each CIDR targeting corresponding peering connections or transit gateway attachments.
    * Run `terraform import hcp_hvn_route.<route-name> <hvn-id>:<hvn-route-id>` for each `hcp_hvn_route`. The `<hvn-route-id>` can be found on the details pages of the corresponding HVN connection in the HCP Portal.
    * Run `terraform plan` and make sure that there are no changes detected by the Terraform.

The examples below walk through the schema upgrade and re-import steps.

### Peering example

Given:
```terraform
resource "hcp_hvn" "hvn" {
  hvn_id         = "prod-hvn"
  region         = "us-west-2"
  cloud_provider = "aws"
}

resource "hcp_aws_network_peering" "peering" {
  hvn_id              = hcp_hvn.hvn.hvn_id
  peer_vpc_id         = "vpc-845f29fc"
  peer_account_id     = "572816266891"
  peer_vpc_region     = "us-west-2"
  peer_vpc_cidr_block = "172.31.0.0/16"
}
```

Rewrite it to the new schema and add corresponding HVN route:
```terraform
resource "hcp_hvn" "hvn" {
  hvn_id         = "prod-hvn"
  region         = "us-west-2"
  cloud_provider = "aws"
}

resource "hcp_aws_network_peering" "peering" {
  hvn_id = hcp_hvn.hvn.hvn_id
  // add `peering_id` that you can find in the HCP Portal
  peering_id      = "f03324a9-4377-4a54-9c15-958fd07ad77b"
  peer_vpc_id     = "vpc-845f29fc"
  peer_account_id = "572816266891"
  peer_vpc_region = "us-west-2"
  // remove `peer_vpc_cidr_block`
  // peer_vpc_cidr_block = "172.31.0.0/16"
}

// Add a `hcp_hvn_route` resource for the peering's CIDR
resource "hcp_hvn_route" "peering-route" {
  hvn_link = hcp_hvn.hvn.self_link
  // you can find this ID in the HCP Portal in the peering details page in the list of routes
  hvn_route_id     = "a8dda9a8-0f69-4fa0-b38c-55be302fdddb"
  destination_cidr = "172.31.0.0/16"
  target_link      = hcp_aws_network_peering.peering.self_link
}
```

Run `import` for the `hcp_hvn_route`:
```shell
$ terraform import hcp_hvn_route.peering-route prod-hvn:a8dda9a8-0f69-4fa0-b38c-55be302fdddb
```

Run `terraform plan` to make sure there are no changes detected by the Terraform:
```shell
$ terraform plan
No changes. Infrastructure is up-to-date.
```

### Transit gateway attachment example

Given:
```terraform
resource "hcp_hvn" "hvn" {
  hvn_id         = "prod-hvn"
  region         = "us-west-2"
  cloud_provider = "aws"
}

resource "hcp_aws_transit_gateway_attachment" "prod" {
  hvn_id                        = hcp_hvn.hvn.hvn_id
  transit_gateway_attachment_id = "prod-tgw-attachment"
  transit_gateway_id            = "tgw-0ee94b1a1167cf89d"
  resource_share_arn            = "arn:aws:ram:us-west-2:..."
  destination_cidrs             = ["10.1.0.0/24", "10.2.0.0/24"]
}
```

Rewrite it to the new schema and add corresponding HVN route:
```terraform
resource "hcp_hvn" "hvn" {
  hvn_id         = "prod-hvn"
  region         = "us-west-2"
  cloud_provider = "aws"
}

resource "hcp_aws_transit_gateway_attachment" "prod" {
  hvn_id                        = hcp_hvn.hvn.hvn_id
  transit_gateway_attachment_id = "prod-tgw-attachment"
  transit_gateway_id            = "tgw-0ee94b1a1167cf89d"
  resource_share_arn            = "arn:aws:ram:us-west-2:..."
  // remove `destination_cidrs`
  // destination_cidrs             = ["10.1.0.0/24", "10.2.0.0/24"]
}

// add a new `hcp_hvn_route` for each CIDR associated with the transit gateway attachment
resource "hcp_hvn_route" "tgw-route-1" {
  hvn_link = hcp_hvn.hvn.self_link
  // you can find this ID in the HCP Portal in the TGW attachment details page in the list of Routes
  hvn_route_id     = "35392425-215a-44ec-bbd0-051bb777ce5f"
  destination_cidr = "10.1.0.0/24"
  target_link      = hcp_aws_transit_gateway_attachment.prod.self_link
}

resource "hcp_hvn_route" "tgw-route-2" {
  hvn_link = hcp_hvn.hvn.self_link
  // you can find this ID in the HCP Portal in the transit gateway attachment details page in the list of routes
  hvn_route_id     = "9867959a-d81b-4e52-ae8e-ca56f9dd06fc"
  destination_cidr = "10.2.0.0/24"
  target_link      = hcp_aws_transit_gateway_attachment.prod.self_link
}
```

Run `import` for each `hcp_hvn_route` you've added:
```shell
$ terraform import hcp_hvn_route.tgw-route-1 prod-hvn:35392425-215a-44ec-bbd0-051bb777ce5f
...

$ terraform import hcp_hvn_route.tgw-route-2 prod-hvn:9867959a-d81b-4e52-ae8e-ca56f9dd06fc
...
```

Run `terraform plan` to make sure there are no changes detected by the Terraform:
```shell
$ terraform plan
No changes. Infrastructure is up-to-date.
```




# hcp_iam_policy (Data Source)

Generates an IAM policy that may be referenced by and applied to other HCP IAM resources, such as the `hcp_project_iam_policy` resource.

To see what each role grants, please see [HCP
Documentation](https://developer.hashicorp.com/hcp/docs/hcp/admin/iam/users#organization).
The basic roles can be referenced as follows:

* `roles/owner`
* `roles/admin`
* `roles/contributor`
* `roles/viewer`

HCP Vault Secrets specific roles can be referenced as shown below, please see [Documentation](https://developer.hashicorp.com/hcp/docs/hcp/admin/iam/users#project) for more details.
* `roles/secrets.app-manager`
* `roles/secrets.app-secret-reader`


## Example Usage

```terraform
data "hcp_iam_policy" "example" {
  bindings = [
    {
      role = "roles/admin"
      principals = [
        "example-user-id-1",
        "example-group-id-1",
        "example-sp-1"
      ]
    },
    {
      role = "roles/contributor"
      principals = [
        "example-user-id-2",
        "example-group-id-2",
      ]
    },
    {
      role = "roles/secrets.app-secret-reader"
      principals = [
        "example-sp-3"
      ]
    },
  ]
}
```

<!-- schema generated by tfplugindocs -->
## Schema

### Required

- `bindings` (Attributes Set) A binding associates a set of principals to a role. (see [below for nested schema](#nestedatt--bindings))

### Read-Only

- `policy_data` (String) The policy data in a format suitable for reference by resources that support setting IAM policy.

<a id="nestedatt--bindings"></a>
### Nested Schema for `bindings`

Required:

- `principals` (Set of String) The set of principals to bind to the given role.
- `role` (String) The role name to bind to the given principals.




# hcp_iam_workload_identity_provider (Resource)

The workload identity provider resource allows federating an external identity to a HCP Service Principal.

## Example Usage: AWS

```terraform
resource "hcp_service_principal" "workload_sp" {
  name = "my-app-runtime"
}

resource "hcp_iam_workload_identity_provider" "example" {
  name              = "aws-example"
  service_principal = hcp_service_principal.workload_sp.resource_name
  description       = "Allow my-app on AWS to act as my-app-runtime service principal"

  aws {
    # Only allow workloads from this AWS Account to exchange identity
    account_id = "123456789012"
  }

  # Only allow workload's running with the correct AWS IAM Role
  conditional_access = "aws.arn matches `^arn:aws:sts::123456789012:assumed-role/my-app-role`"
}
```

## Example Usage: Azure

```terraform
resource "hcp_service_principal" "workload_sp" {
  name = "my-app-runtime"
}

resource "hcp_iam_workload_identity_provider" "example" {
  name              = "azure-example"
  service_principal = hcp_service_principal.workload_sp.resource_name
  description       = "Allow my-app on Azure to act as my-app-runtime service principal"

  oidc {
    # The issuer uri should be as follows where the ID in the path is replaced
    # with your Azure Tenant ID
    issuer_uri = "https://sts.windows.net/60a0d497-45cd-413d-95ca-e154bbb9129b"

    # The allowed audience should be set to the Object ID of the Azure Managed
    # Identity. In this example, this would be the Object ID of a User Managed
    # Identity that will be attached to "my-app" workloads on Azure.
    allowed_audiences = ["api://10bacc1d-f3f5-499d-a14c-684c1471b27f"]
  }

  # Only allow workload's that are assigned the expected managed identity.
  # The access_token given to Azure workload's will have the oid claim set to
  # that of the managed identity.
  conditional_access = "jwt_claims.oid == `066c643f-86c0-490a-854c-35e77ddc7851`"
}
```

## Example Usage: GCP

```terraform
resource "hcp_service_principal" "workload_sp" {
  name = "my-app-runtime"
}

resource "hcp_iam_workload_identity_provider" "example" {
  name              = "gcp-example"
  service_principal = hcp_service_principal.workload_sp.resource_name
  description       = "Allow my-app on GCP to act as my-app-runtime service principal"

  oidc {
    issuer_uri = "https://accounts.google.com"
  }

  # Only allow workload's that are assigned the expected service account ID
  # GCP will set the subject to that of the service account associated with the
  # workload.
  conditional_access = "jwt_claims.sub == `107517467455664443766`"
}
```

<!-- schema generated by tfplugindocs -->
## Schema

### Required

- `conditional_access` (String) conditional_access is a hashicorp/go-bexpr string that is evaluated when exchanging tokens. It restricts which upstream identities are allowed to access the service principal.
- `name` (String) The workload identity provider's name. Ideally, this should be descriptive of the workload being federated.
- `service_principal` (String) The service principal's resource name for which the workload identity provider will be created for. Only service principals created within a project are allowed.

### Optional

- `aws` (Attributes) (see [below for nested schema](#nestedatt--aws))
- `description` (String) A description for the workload identity provider.
- `oidc` (Attributes) (see [below for nested schema](#nestedatt--oidc))

### Read-Only

- `resource_id` (String) The workload identity provider's unique identifier
- `resource_name` (String) The workload identity providers's resource name in the format `iam/project/<project_id>/service-principal/<sp_name>/workload-identity-provider/<name>`

<a id="nestedatt--aws"></a>
### Nested Schema for `aws`

Required:

- `account_id` (String) The AWS Account ID that is allowed to exchange workload identities.


<a id="nestedatt--oidc"></a>
### Nested Schema for `oidc`

Required:

- `issuer_uri` (String) The URL of the OIDC Issuer that is allowed to exchange workload identities.

Optional:

- `allowed_audiences` (Set of String) allowed_audiences is the set of audiences set on the access token that are allowed to exchange identities. The access token must have an audience that is contained in this set. If no audience is set, the default allowed audience will be the resource name of the WorkloadIdentityProvider.

## Import

Import is supported using the following syntax:

```shell
# Workload identity providers can be imported by specifying the resource name
terraform import hcp_iam_workload_identity_provider.example iam/project/840e3701-55b6-4f86-8c17-b1fe397303c5/service-principal/my-app-runtime/workload-identity-provider/aws
```




# HashiCorp Cloud Platform (HCP) Provider

-> Please refer to the provider's [Release Notes](https://github.com/hashicorp/terraform-provider-hcp/releases) for critical fixes.

-> Consul on Azure is available. See the [Get started with end-to-end deployment configuration](https://developer.hashicorp.com/consul/tutorials/cloud-deploy-automation/consul-end-to-end-overview) tutorial.

The HCP provider provides resources to manage [HashiCorp Cloud Platform](https://cloud.hashicorp.com/) (HCP) resources.

![HCP Architecture Diagram](https://content.hashicorp.com/api/assets?product=hcp-docs&version=refs/heads/main&asset=public/img/docs/hcp-arch-diagram.png)

## Authenticating with HCP

The HCP provider supports authentication via a Client ID and a Client Secret. The [authentication guide](guides/auth.md) describes how to obtain client credentials.

## Getting Started

Everything in HashiCorp Cloud Platform (HCP) starts with the HashiCorp Virtual Network (HVN).

HVNs enable you to deploy HashiCorp Cloud products without having to manage the networking details. They give you a simple setup for creating a network on AWS, in the region of your choice, and with the option to specify a CIDR range.

Creating a network peering from your HVN will allow you to connect and launch AWS resources to your HCP account.
Peer your Amazon VPC with your HVN to enable resource access. After creating, you will need to accept the peering request and set up your VPC’s security groups and routing table on your AWS account. The Amazon VPC can be managed with the [AWS provider](https://registry.terraform.io/providers/hashicorp/aws/latest/docs).

Once you have an HVN, HCP Consul and HCP Vault enable you to quickly deploy Consul and Vault clusters in AWS across a variety of environments while offloading the operations burden to the SRE experts at HashiCorp.

One final note: with a fully deployed HCP Consul, you need to deploy Consul clients inside of the peered VPC to fully access your Consul features.

```terraform
// Pin the version
terraform {
  required_providers {
    hcp = {
      source  = "hashicorp/hcp"
      version = "~> 0.102.0"
    }
  }
}

// Configure the provider
provider "hcp" {}

// Use the cloud provider AWS to provision resources that will be connected to HCP
provider "aws" {
  region = var.region
}

// Create an HVN
resource "hcp_hvn" "example_hvn" {
  hvn_id         = "hcp-tf-example-hvn"
  cloud_provider = "aws"
  region         = var.region
  cidr_block     = "172.25.16.0/20"
}

// Create a peering connection between two HVNs
resource "hcp_hvn" "second_example_hvn" {
  hvn_id         = "hcp-tf-second-example-hvn"
  cloud_provider = "aws"
  region         = var.region
  cidr_block     = "172.18.16.0/20"
}

resource "hcp_hvn_peering_connection" "example" {
  hvn_1 = hcp_hvn.example_hvn.self_link
  hvn_2 = hcp_hvn.second_example_hvn.self_link
}

// Create a VPC for the HVN to peer into
resource "aws_vpc" "main" {
  cidr_block = "172.25.0.0/20"
}

data "aws_arn" "main" {
  arn = aws_vpc.main.arn
}

resource "aws_vpc_peering_connection_accepter" "main" {
  vpc_peering_connection_id = hcp_aws_network_peering.example_peering.provider_peering_id
  auto_accept               = true
}

// Create a network peering between the HVN and the AWS VPC
resource "hcp_aws_network_peering" "example" {
  hvn_id          = hcp_hvn.example_hvn.hvn_id
  peering_id      = "hcp-tf-example-peering"
  peer_vpc_id     = aws_vpc.main.id
  peer_account_id = aws_vpc.main.owner_id
  peer_vpc_region = data.aws_arn.main.region
}

// Create an HVN route that targets your HCP network peering and matches your AWS VPC's CIDR block
resource "hcp_hvn_route" "example" {
  hvn_link         = hcp_hvn.hvn.self_link
  hvn_route_id     = "hcp-tf-example-hvn-route"
  destination_cidr = aws_vpc.main.cidr_block
  target_link      = hcp_aws_network_peering.example.self_link
}

// Create a Consul cluster in the same region and cloud provider as the HVN
resource "hcp_consul_cluster" "example" {
  hvn_id     = hcp_hvn.example_hvn.hvn_id
  cluster_id = "hcp-tf-example-consul-cluster"
  tier       = "development"
}

// Create a Vault cluster in the same region and cloud provider as the HVN
resource "hcp_vault_cluster" "example" {
  cluster_id = "hcp-tf-example-vault-cluster"
  hvn_id     = hcp_hvn.example_hvn.hvn_id
}
```

<!-- schema generated by tfplugindocs -->
## Schema

### Optional

- `client_id` (String) The OAuth2 Client ID for API operations.
- `client_secret` (String) The OAuth2 Client Secret for API operations.
- `credential_file` (String) The path to an HCP credential file to use to authenticate the provider to HCP. You can alternatively set the HCP_CRED_FILE environment variable to point at a credential file as well. Using a credential file allows you to authenticate the provider as a service principal via client credentials or dynamically based on Workload Identity Federation.
- `project_id` (String) The default project in which resources should be created.
- `workload_identity` (Block List) Allows authenticating the provider by exchanging the OAuth 2.0 access token or OpenID Connect token specified in the `token_file` for a HCP service principal using Workload Identity Federation. (see [below for nested schema](#nestedblock--workload_identity))

<a id="nestedblock--workload_identity"></a>
### Nested Schema for `workload_identity`

Required:

- `resource_name` (String) The resource_name of the Workload Identity Provider to exchange the token with.

Optional:

- `token` (String) The JWT token retrieved from an OpenID Connect (OIDC) or OAuth2 provider. At least one of `token_file` or `token` must be set, if both are set then `token` takes precedence.
- `token_file` (String) The path to a file containing a JWT token retrieved from an OpenID Connect (OIDC) or OAuth2 provider. At least one of `token_file` or `token` must be set, if both are set then `token` takes precedence.
-> **Note:** See the [authentication guide](guides/auth.md) about a use case when specifying `project_id` is needed.

## API
The terraform provider accesses [HCP API](https://developer.hashicorp.com/hcp/docs/hcp/api) to facilitate workflows.

In addition to the documentation provided, the provider also accesses [HashiCorp Services Status page](https://status.hashicorp.com/).

For more information about HCP, please review our [documentation page](https://developer.hashicorp.com/hcp/docs/).




# hcp_log_streaming_destination (Resource)

The Streaming Destination resource allows users to configure an external log system to stream HCP logs to.

To manage destinations, you must authenticate with an organization-level service principal with
the `contributor` or `admin` role.

## Example Usage: CloudWatch

```terraform
resource "hcp_log_streaming_destination" "example_cloudwatch" {
  name = "example_cloudwatch"
  cloudwatch = {
    external_id    = "an-external-id"
    region         = "us-east-1"
    role_arn       = "arn:aws:iam::111111111:role/hcp-log-streaming"
    log_group_name = "a-log-group-name"
  }
}
```

## Example Usage: DataDog

```terraform
resource "hcp_log_streaming_destination" "example_datadog" {
  name = "example_datadog"
  datadog = {
    endpoint        = "https://datadog-api.com"
    api_key         = "API_KEY_VALUE_HERE"
    application_key = "APPLICATION_VALUE_HERE"
  }
}
```

## Example Usage: SplunkCloud

```terraform
resource "hcp_log_streaming_destination" "example_splunk_cloud" {
  name = "example_splunk_cloud"
  splunk_cloud = {
    endpoint = "https://http-inputs-tenant.splunkcloud.com:443/services/collector/event"
    token    = "someSuperSecretToken"
  }
}
```

<!-- schema generated by tfplugindocs -->
## Schema

### Required

- `name` (String) The HCP Log Streaming Destination’s name.

### Optional

- `cloudwatch` (Attributes) (see [below for nested schema](#nestedatt--cloudwatch))
- `datadog` (Attributes) (see [below for nested schema](#nestedatt--datadog))
- `splunk_cloud` (Attributes) (see [below for nested schema](#nestedatt--splunk_cloud))

### Read-Only

- `streaming_destination_id` (String) The ID of the HCP Log Streaming Destination

<a id="nestedatt--cloudwatch"></a>
### Nested Schema for `cloudwatch`

Required:

- `external_id` (String, Sensitive) The external_id to provide when assuming the aws IAM role.
- `region` (String) The region the CloudWatch destination is set up to stream to.
- `role_arn` (String) The role_arn that will be assumed to stream logs.

Optional:

- `log_group_name` (String) The log_group_name of the CloudWatch destination.


<a id="nestedatt--datadog"></a>
### Nested Schema for `datadog`

Required:

- `api_key` (String, Sensitive) The value for the DD-API-KEY to send when making requests to DataDog.
- `endpoint` (String) The Datadog endpoint to send logs to.

Optional:

- `application_key` (String, Sensitive) The value for the DD-APPLICATION-KEY to send when making requests to DataDog.


<a id="nestedatt--splunk_cloud"></a>
### Nested Schema for `splunk_cloud`

Required:

- `endpoint` (String) The Splunk Cloud endpoint to send logs to.
- `token` (String, Sensitive) The authentication token that will be used by the platform to access Splunk Cloud.




# Multi-project Migration Guide

HCP now supports multiple projects. You may migrate your HCP Terraform configuration in the following ways.

-> **Note:** Resources cannot be moved to new projects. Changing a resource's project will force its recreation. Before creating additional projects, we recommend configuring the current sole project as the provider's default project to ensure no recreation occurs.

## 1. Default to oldest project (no change required)

The HVN in this example will be created in the sole existing project, or if there is more than one project, the oldest project.

```terraform
provider "hcp" {}

resource "hcp_hvn" "test" {
  hvn_id         = "test-hvn"
  cloud_provider = "aws"
  region         = "us-west-2"
}
```

## 2. Configure a default project on provider

The HVN in this example will be created in the project configured at the provider level.

```terraform
provider "hcp" {
  project_id = "f709ec73-55d4-46d8-897d-816ebba28778"
}

resource "hcp_hvn" "test" {
  hvn_id         = "test-hvn"
  cloud_provider = "aws"
  region         = "us-west-2"
}
```

## 3. Configure projects on resource

The HVN will be created in its configured project, while the HCP Consul cluster will be created in its different configured project.
Since no project is configured on the provider, the default project will be the oldest project.

```terraform
provider "hcp" {}

resource "hcp_hvn" "test" {
  hvn_id         = "test-hvn"
  project_id     = "f709ec73-55d4-46d8-897d-816ebba28778"
  cloud_provider = "aws"
  region         = "us-west-2"
}

resource "hcp_consul_cluster" "consul_cluster" {
  cluster_id = "test-cluster"
  hvn_id     = hcp_hvn.test.hvn_id
  project_id = "0f8c263e-8eb4-4a7f-a0cc-7e476afb9fd2"
  tier       = "development"
}
```

### Override provider project with resource project

Projects may be set at both the resource and provider level. The resource-configured project is always preferred over the provider-configured project.

```terraform
provider "hcp" {
  project_id = "f709ec73-55d4-46d8-897d-816ebba28778"
}

# This HVN will be created in the project "0f8c263e-8eb4-4a7f-a0cc-7e476afb9fd2"
resource "hcp_hvn" "test" {
  hvn_id         = "test-hvn"
  project_id     = "0f8c263e-8eb4-4a7f-a0cc-7e476afb9fd2"
  cloud_provider = "aws"
  region         = "us-west-2"
}
```

## Imports

If no project is configured at the provider level, imported resources must include their project ID to ensure uniqueness.

```shell
# terraform import {resource_type}.{resource_name} {project_id}:{hvn_id}

$ terraform import hcp_hvn.test f709ec73-55d4-46d8-897d-816ebba28778:test-hvn
```




# hcp_notifications_webhook (Resource)

The webhook resource manages a HCP webhook, used to notify external systems about a project resource's lifecycle events

## Example Usage

```terraform
resource "hcp_notifications_webhook" "example" {
  name        = "example-webhook"
  description = "Notify for all of the events for all Packer artifact versions existing in the project."

  config = {
    url = "https://example.com"
  }

  subscriptions = [
    {
      events = [
        {
          actions = ["*"]
          source  = "hashicorp.packer.version"
        }
      ]
    }
  ]
}
```

<!-- schema generated by tfplugindocs -->
## Schema

### Required

- `config` (Attributes) The webhook configuration used to deliver event payloads. (see [below for nested schema](#nestedatt--config))
- `name` (String) The webhook's name.

### Optional

- `description` (String) The webhook's description. Descriptions are useful for helping others understand the purpose of the webhook.
- `enabled` (Boolean) Indicates if the webhook should receive payloads for the subscribed events. Defaults to `true`.
- `project_id` (String) The ID of the project to create the webhook under. If unspecified, the webhook will be created in the project the provider is configured with.
- `subscriptions` (Attributes List) Set of events to subscribe the webhook to all resources or a specific resource in the project. (see [below for nested schema](#nestedatt--subscriptions))

### Read-Only

- `resource_id` (String) The webhook's unique identifier.
- `resource_name` (String) The webhooks's resource name in the format `webhook/project/<project_id>/geo/us/webhook/<name>`.

<a id="nestedatt--config"></a>
### Nested Schema for `config`

Required:

- `url` (String) The HTTP or HTTPS destination URL that HCP delivers the event payloads to. 
The destination must be able to use the HCP webhook 
[payload](https://developer.hashicorp.com/hcp/docs/hcp/admin/projects/webhooks#webhook-payload).

Optional:

- `hmac_key` (String, Sensitive) The arbitrary secret that HCP uses to sign all its webhook requests. This is a write-only field, it is written once and not visible thereafter.


<a id="nestedatt--subscriptions"></a>
### Nested Schema for `subscriptions`

Required:

- `events` (Attributes List) The information about the events of a webhook subscription. The service that owns the resource is responsible for maintaining events. Refer to the service's webhook documentation for more information. (see [below for nested schema](#nestedatt--subscriptions--events))

Optional:

- `resource_id` (String) Refers to the resource the webhook is subscribed to. If not set, the webhook subscribes to the emitted events listed in events for any resource in the webhook's project.

<a id="nestedatt--subscriptions--events"></a>
### Nested Schema for `subscriptions.events`

Required:

- `actions` (List of String) The list of event actions subscribed for the resource type set as the [source](#source). For example, `["create", "update"]`. When the action is '*', it means that the webhook is subscribed to all event actions for the event source.
- `source` (String) The resource type of the source of the event. For example, `hashicorp.packer.version`. Event source might not be the same type as the resource that the webhook is subscribed to ([resource_id](#resource_id)) if the event is from a descendant resource. For example, webhooks are subscribed to a `hashicorp.packer.registry` and receive events for descendent resources such as a `hashicorp.packer.version`.

## Import

Import is supported using the following syntax:

```shell
# HCP Webhook can be imported by specifying the webhook resource name
# The webhook resource name is in the format webhook/project/{project_id}/geo/us/webhook/{webhook_name}
terraform import hcp_notifications_webhook.example webhook/project/840e3701-55b6-4f86-8c17-b1fe397303c5/geo/us/webhook/example-webhook
```




# hcp_organization (Data Source)

The organization data source retrieves the HCP organization the provider is configured for.

## Example Usage

```terraform
data "hcp_organization" "example" {
}
```

<!-- schema generated by tfplugindocs -->
## Schema

### Read-Only

- `name` (String) The organization's name.
- `resource_id` (String) The organization's unique identifier
- `resource_name` (String) The organization's resource name in format "organization/<resource_id>"




# hcp_organization_iam_binding (Resource)

Updates the organization's IAM policy to bind a role to a new member. Existing bindings are preserved.

~> **Note:** `hcp_organization_iam_binding` can not be used in conjunction with
`hcp_organization_iam_policy`.

## Example Usage

```terraform
data "hcp_organization" "example_org" {}

resource "hcp_service_principal" "sp" {
  name   = "example-sp"
  parent = data.hcp_organization.example_org.resource_name
}

resource "hcp_organization_iam_binding" "example" {
  principal_id = hcp_service_principal.sp.resource_id
  role         = "roles/contributor"
}
```

<!-- schema generated by tfplugindocs -->
## Schema

### Required

- `principal_id` (String) The principal to bind to the given role.
- `role` (String) The role name to bind to the given principal.




# hcp_organization_iam_policy (Resource)

!> **Be Careful!** You can accidentally lock yourself and others out of your
organization using this resource. In general, this resource should only be used
with organizations fully managed by Terraform. If you are trying to additively
give permissions to the organization, prefer using
`hcp_organization_iam_binding`. If you do use this resource, it is recommended
to import the policy and carefully inspecting the planned changes before
applying.

Sets the organization's IAM policy and replaces any existing policy.

~> **Note:** `hcp_organization_iam_policy` can not be used in conjunction with
`hcp_organization_iam_binding`.

## Example Usage

```terraform
data "hcp_iam_policy" "example" {
  bindings = [
    {
      role = "roles/owner"
      principals = [
        "example-user-id-1",
      ]
    },
    {
      role = "roles/admin"
      principals = [
        "example-group-id-1",
        "example-sp-1"
      ]
    },
  ]
}

resource "hcp_organization_iam_policy" "org_policy" {
  policy_data = data.hcp_iam_policy.example.policy_data
}
```

<!-- schema generated by tfplugindocs -->
## Schema

### Required

- `policy_data` (String) The policy to apply.

### Read-Only

- `etag` (String) The etag captures the existing state of the policy.

## Import

Import is supported using the following syntax:

```shell
# No import ID is needed. The organization is determined by the provider
# configuration.
terraform import hcp_organization_iam_policy.example ""
```




# hcp_packer_artifact (Data Source)

The HCP Packer Artifact data source retrieves information about an Artifact.

## Example Usage

### Single artifact sourcing

```terraform
data "hcp_packer_artifact" "ubuntu-east" {
  bucket_name  = "hardened-ubuntu-16-04"
  channel_name = "production"
  platform     = "aws"
  region       = "us-east-1"
}

output "packer-registry-ubuntu-east-1" {
  value = data.hcp_packer_artifact.ubuntu-east.external_identifier
}
```

~> **Note:** The `channel` attribute in this data source may incur a billable request to HCP Packer. This attribute is intended for convenience when using a single artifact. When sourcing multiple artifacts from a single version, the `hcp_packer_version` data source is the alternative for querying a channel just once.

### Multiple artifact sourcing from a single version

```terraform
data "hcp_packer_version" "hardened-source" {
  bucket_name  = "hardened-ubuntu-16-04"
  channel_name = "production"
}

data "hcp_packer_artifact" "ubuntu-east" {
  bucket_name         = "hardened-ubuntu-16-04"
  version_fingerprint = data.hcp_packer_version.hardened-source.fingerprint
  platform            = "aws"
  region              = "us-east-1"
}

data "hcp_packer_artifact" "ubuntu-west" {
  bucket_name         = "hardened-ubuntu-16-04"
  version_fingerprint = data.hcp_packer_version.hardened-source.fingerprint
  platform            = "aws"
  region              = "us-west-1"
}

output "packer-registry-ubuntu-east-1" {
  value = data.hcp_packer_artifact.ubuntu-east.external_identifier
}

output "packer-registry-ubuntu-west-1" {
  value = data.hcp_packer_artifact.ubuntu-west.external_identifier
}
```

~> **Note:** This data source only returns the first found artifact's metadata filtered by the given arguments, from the returned list of artifacts associated with the specified version. Therefore, if multiple artifacts exist in the same region, it will only pick one of them. In this case, you can filter artifacts by a source build name (Ex: `amazon-ebs.example`) using the `component_type` optional argument.

<!-- schema generated by tfplugindocs -->
## Schema

### Required

- `bucket_name` (String) The name of the HCP Packer Bucket where the Artifact is located.
- `platform` (String) Name of the platform where the HCP Packer Artifact is stored.
- `region` (String) The Region where the HCP Packer Artifact is stored, if any.

### Optional

- `channel_name` (String) The name of the HCP Packer Channel the Version containing this Artifact is assigned to.
The Version currently assigned to the Channel will be fetched. 
Exactly one of `channel_name` or `version_fingerprint` must be provided.
- `component_type` (String) Name of the Packer builder that built this Artifact. Ex: `amazon-ebs.example`.
- `project_id` (String) The ID of the HCP Organization where the Artifact is located
- `version_fingerprint` (String) The fingerprint of the HCP Packer Version where the Artifact is located. 
If provided in the config, it is used to fetch the Version.
Exactly one of `channel_name` or `version_fingerprint` must be provided.

### Read-Only

- `build_id` (String) The ULID of the HCP Packer Build where the Artifact is located.
- `created_at` (String) The creation time of this HCP Packer Artifact.
- `external_identifier` (String) An external identifier for the HCP Packer Artifact.
- `id` (String) The ULID of the HCP Packer Artifact.
- `labels` (Map of String) Labels associated with the build containing this image.
- `organization_id` (String) The ID of the HCP Organization where the Artifact is located
- `packer_run_uuid` (String) The UUID of the build containing this image.
- `revoke_at` (String) The revocation time of the HCP Packer Version containing this Artifact. This field will be null for any Version that has not been revoked or scheduled for revocation.




# hcp_packer_bucket (Resource)

The Packer Bucket resource allows you to manage a bucket within an active HCP Packer Registry.

## Example Usage

```terraform
resource "hcp_packer_bucket" "staging" {
  name = "alpine"
}
```

<!-- schema generated by tfplugindocs -->
## Schema

### Required

- `name` (String) The bucket's name.

### Optional

- `project_id` (String) The ID of the project to create the bucket under. If unspecified, the bucket will be created in the project the provider is configured with.

### Read-Only

- `created_at` (String) The creation time of this bucket
- `organization_id` (String) The ID of the HCP organization where this bucket is located.
- `resource_name` (String) The buckets's HCP resource name in the format `packer/project/<project_id>/packer/<name>`.

## Import

Import is supported using the following syntax:

```shell
# Using a HCP Packer Bucket Resource Name
# packer/project/{project_id}/bucket/{bucket_name}
terraform import hcp_packer_bucket.alpine packer/project/f709ec73-55d4-46d8-897d-816ebba28778/bucket/alpine
```




# hcp_packer_bucket_iam_binding (Resource)

Updates the HCP Packer Bucket IAM policy to bind a role to a new member. Existing bindings are preserved.

~> **Note:** `hcp_packer_bucket_iam_binding` cannot be used in conjunction with
`hcp_packer_bucket_iam_policy`.

## Example Usage

```terraform
resource "hcp_service_principal" "my-sp" {
  name = "my-sp"
}

resource "hcp_packer_bucket" "production" {
  name = "production"
}

resource "hcp_packer_bucket_iam_binding" "example" {
  resource_name = hcp_packer_bucket.production.resource_name
  principal_id  = hcp_service_principal.my-sp.resource_id
  role          = "roles/contributor"
}
```

<!-- schema generated by tfplugindocs -->
## Schema

### Required

- `principal_id` (String) The principal to bind to the given role.
- `resource_name` (String) The bucket's resource name in the format packer/project/<project ID>/bucket/<bucket name>.
- `role` (String) The role name to bind to the given principal.




# hcp_packer_bucket_iam_policy (Resource)

Sets the HCP Packer Bucket IAM policy and replaces any existing policy.

~> **Note:** `hcp_packer_bucket_iam_policy` can not be used in conjunction with
`hcp_packer_bucket_iam_binding`.

## Example Usage

```terraform
data "hcp_iam_policy" "mypolicy" {
  bindings = [
    {
      role = "roles/contributor"
      principals = [
        "user-principal-id-1",
        "service-principal-id-1",
      ]
    },
  ]
}

resource "hcp_packer_bucket" "production" {
  name = "production"
}

resource "hcp_packer_bucket_iam_policy" "example" {
  resource_name = hcp_packer_bucket.production.resource_name
  policy_data   = data.hcp_iam_policy.mypolicy.policy_data
}
```

<!-- schema generated by tfplugindocs -->
## Schema

### Required

- `policy_data` (String) The policy to apply.
- `resource_name` (String) The bucket's resource name in the format packer/project/<project ID>/bucket/<bucket name>.

### Read-Only

- `etag` (String) The etag captures the existing state of the policy.

## Import

Import is supported using the following syntax:

```shell
# Using a HCP Packer Bucket Resource Name
# packer/project/{project_id}/bucket/{bucket_name}
terraform import hcp_packer_bucket.alpine packer/project/f709ec73-55d4-46d8-897d-816ebba28778/bucket/alpine
```



# hcp_packer_bucket_names (Data Source)

The Packer Bucket Names data source gets the names of all of the buckets in a single HCP Packer registry.

## Example Usage

```terraform
data "hcp_packer_bucket_names" "all" {}
```

<!-- schema generated by tfplugindocs -->
## Schema

### Optional

- `project_id` (String) The ID of the HCP project where the HCP Packer registry is located.
- `timeouts` (Block, Optional) (see [below for nested schema](#nestedblock--timeouts))

### Read-Only

- `id` (String) The ID of this resource.
- `names` (Set of String) A set of names for all buckets in the HCP Packer registry.
- `organization_id` (String) The ID of the organization where the HCP Packer registry is located.

<a id="nestedblock--timeouts"></a>
### Nested Schema for `timeouts`

Optional:

- `default` (String)




# hcp_packer_channel (Resource)

The Packer Channel resource allows you to manage a bucket channel within an active HCP Packer Registry.

## Example Usage

```terraform
resource "hcp_packer_channel" "staging" {
  name        = "staging"
  bucket_name = "alpine"
}
```

<!-- schema generated by tfplugindocs -->
## Schema

### Required

- `bucket_name` (String) The name of the HCP Packer Registry bucket where the channel should be created.
- `name` (String) The name of the channel being managed.

### Optional

- `project_id` (String) The ID of the HCP project where this channel is located. 
If not specified, the project specified in the HCP Provider config block will be used, if configured.
If a project is not configured in the HCP Provider config block, the oldest project in the organization will be used.
- `restricted` (Boolean) If true, the channel is only visible to users with permission to create and manage it. If false, the channel is visible to every member of the organization.
- `timeouts` (Block, Optional) (see [below for nested schema](#nestedblock--timeouts))

### Read-Only

- `author_id` (String) The author of this channel.
- `created_at` (String) The creation time of this channel.
- `id` (String) The ID of this resource.
- `managed` (Boolean) If true, the channel is an HCP Packer managed channel
- `organization_id` (String) The ID of the HCP organization where this channel is located.
- `updated_at` (String) The time this channel was last updated.

<a id="nestedblock--timeouts"></a>
### Nested Schema for `timeouts`

Optional:

- `create` (String)
- `default` (String)
- `delete` (String)
- `update` (String)

## Import

Import is supported using the following syntax:

```shell
# Using an explicit project ID, the import ID is:
# {project_id}:{bucket_name}:{channel_name}
terraform import hcp_packer_channel.staging f709ec73-55d4-46d8-897d-816ebba28778:alpine:staging
# Using the provider-default project ID, the import ID is:
# {bucket_name}:{channel_name}
terraform import hcp_packer_channel.staging alpine:staging
```




# hcp_packer_channel_assignment (Resource)

The Packer Channel Assignment resource allows you to manage the version assigned to a channel in an active HCP Packer Registry.

## Example Usage

```terraform
resource "hcp_packer_channel_assignment" "staging" {
  bucket_name         = "alpine"
  channel_name        = "staging"
  version_fingerprint = "01H1ZMW0Q2W6FT4FK27FQJCFG7"
}

# To set the channel to have no assignment, use "none" as the version_fingerprint value.
resource "hcp_packer_channel_assignment" "staging" {
  bucket_name         = "alpine"
  channel_name        = "staging"
  version_fingerprint = "none"
}
```

<!-- schema generated by tfplugindocs -->
## Schema

### Required

- `bucket_name` (String) The slug of the HCP Packer bucket where the channel is located.
- `channel_name` (String) The name of the HCP Packer channel being managed.

### Optional

- `project_id` (String) The ID of the HCP project where the channel is located. 
If not specified, the project specified in the HCP Provider config block will be used, if configured.
If a project is not configured in the HCP Provider config block, the oldest project in the organization will be used.
- `timeouts` (Block, Optional) (see [below for nested schema](#nestedblock--timeouts))
- `version_fingerprint` (String) The fingerprint of the version assigned to the channel.

### Read-Only

- `id` (String) The ID of this resource.
- `organization_id` (String) The ID of the HCP organization where this channel is located. Always the same as the associated channel.

<a id="nestedblock--timeouts"></a>
### Nested Schema for `timeouts`

Optional:

- `create` (String)
- `default` (String)
- `delete` (String)
- `update` (String)

## Import

Import is supported using the following syntax:

```shell
# Using an explicit project ID, the import ID is:
# {project_id}:{bucket_name}:{channel_name}
terraform import hcp_packer_channel_assignment.staging f709ec73-55d4-46d8-897d-816ebba28778:alpine:staging
# Using the provider-default project ID, the import ID is:
# {bucket_name}:{channel_name}
terraform import hcp_packer_channel_assignment.staging alpine:staging
```




# hcp_packer_run_task (Resource)

-> **Note:** This resource is currently in public beta.

The Packer Run Task resource allows you to regenerate the HMAC key for an HCP Packer Registry's run task.

If you do not need to regenerate the HMAC key, it is recommended to use the `hcp_packer_run_task` data source instead.

## Example Usage

```terraform
resource "hcp_packer_run_task" "registry" {}

# Configuring the HMAC Key to regenerate on apply
# NOTE: While `regenerate_hmac` is set to `true` the key will be regenerated on every apply.
resource "hcp_packer_run_task" "registry" {
  regenerate_hmac = true
}
```

<!-- schema generated by tfplugindocs -->
## Schema

### Optional

- `project_id` (String) The ID of the HCP project where the HCP Packer Registry is located. 
If not specified, the project specified in the HCP Provider config block will be used, if configured.
If a project is not configured in the HCP Provider config block, the oldest project in the organization will be used.
- `regenerate_hmac` (Boolean) If true, the HMAC Key (`hmac_key`) will be regenerated during `terraform apply`. While set to true, the key will be regenerated on every `terraform apply` until `regenerate_hmac` is set to false or removed from the config.
- `timeouts` (Block, Optional) (see [below for nested schema](#nestedblock--timeouts))

### Read-Only

- `endpoint_url` (String) A unique HCP Packer URL, specific to your HCP organization and HCP Packer registry. The Terraform Cloud run task will send a payload to this URL for image validation.
- `hmac_key` (String, Sensitive) A secret key that lets HCP Packer verify the run task request.
- `id` (String) The ID of this resource.
- `organization_id` (String) The ID of the HCP organization where this channel is located. Always the same as the associated channel.

<a id="nestedblock--timeouts"></a>
### Nested Schema for `timeouts`

Optional:

- `create` (String)
- `default` (String)
- `delete` (String)
- `update` (String)




# hcp_packer_version (Data Source)

The HCP Packer Version data source retrieves information about a Version.

## Example Usage

```terraform
data "hcp_packer_version" "hardened-source" {
  bucket_name  = "hardened-ubuntu-16-04"
  channel_name = "dev"
}
```

<!-- schema generated by tfplugindocs -->
## Schema

### Required

- `bucket_name` (String) The name of the HCP Packer Bucket where the Version is located
- `channel_name` (String) The name of the HCP Packer Channel the Version is assigned to.
The version currently assigned to the Channel will be fetched.

### Optional

- `project_id` (String) The ID of the HCP Organization where the Version is located

### Read-Only

- `author_id` (String) The name of the person who created this HCP Packer Version
- `created_at` (String) The creation time of this HCP Packer Version
- `fingerprint` (String) The fingerprint of the HCP Packer Version
- `id` (String) The ULID of the HCP Packer Version
- `name` (String) The name of the HCP Packer Version
- `organization_id` (String) The ID of the HCP Organization where the Version is located
- `revoke_at` (String) The revocation time of this HCP Packer Version. This field will be null for any Version that has not been revoked or scheduled for revocation
- `updated_at` (String) The last time this HCP Packer Version was updated




# Managing HCP Packer Bucket IAM Policies

You can grant specific users, service principals, or groups contributor or admin level access to a specific HCP Packer bucket using either a `hcp_packer_bucket_iam_binding` or `hcp_packer_bucket_iam_policy` resource.  Whenever a user is invited to a project they will have read level access to all resources, but you can restrict which of the principals in your project can maintain specific buckets.

A resource's policy is a list of bindings to assign roles to multiple users, groups, or service principals. The `hcp_packer_bucket_iam_policy` resource sets the Bucket IAM policy and replaces any existing policy.

The following example assigns the role `contributor` to a user principal and a service principal for the `production` bucket.

```terraform
data "hcp_iam_policy" "mypolicy" {
  bindings = [
    {
      role = "roles/contributor"
      principals = [
        "user-principal-id-1",
        "service-principal-id-1",
      ]
    },
  ]
}

resource "hcp_packer_bucket" "production" {
  name = "production"
}

resource "hcp_packer_bucket_iam_policy" "example" {
  resource_name = hcp_packer_bucket.production.resource_name
  policy_data   = data.hcp_iam_policy.mypolicy.policy_data
}
```

The following example assigns role contriubtor for a service principal to the production bucket, and also preserves existing bindings.

```terraform
resource "hcp_service_principal" "my-sp" {
  name = "my-sp"
}

resource "hcp_packer_bucket" "production" {
  name = "production"
}

resource "hcp_packer_bucket_iam_binding" "example" {
  resource_name = hcp_packer_bucket.production.resource_name
  principal_id  = hcp_service_principal.my-sp.resource_id
  role          = "roles/contributor"
}
```




# Advanced Packer Channel Management

You can integrate multiple HCP Packer resources and data sources to perform advanced channel management tasks.

## Setting the channel assignment on a Terraform-managed channel

```terraform
resource "hcp_packer_channel" "advanced" {
  name        = "advanced"
  bucket_name = "alpine"
}

resource "hcp_packer_channel_assignment" "advanced" {
  bucket_name         = hcp_packer_channel.advanced.bucket_name
  channel_name        = hcp_packer_channel.advanced.name
  version_fingerprint = "01H1ZMW0Q2W6FT4FK27FQJCFG7"
}
```

## Setting the channel assignment to the latest complete version

```terraform
data "hcp_packer_version" "alpine_latest" {
  bucket_name  = "alpine"
  channel_name = "latest"
}

resource "hcp_packer_channel" "alpine_advanced" {
  name        = "advanced"
  bucket_name = data.hcp_packer_version.alpine_latest.bucket_name
}

resource "hcp_packer_channel_assignment" "alpine_advanced" {
  bucket_name         = hcp_packer_channel.alpine_advanced.bucket_name
  channel_name        = hcp_packer_channel.alpine_advanced.name
  version_fingerprint = data.hcp_packer_version.alpine_latest.fingerprint
}
```

## Automatically creating channels for new and existing buckets

```terraform
data "hcp_packer_bucket_names" "all" {}

resource "hcp_packer_channel" "release" {
  for_each = data.hcp_packer_bucket_names.all.names

  name        = "release"
  bucket_name = each.key
}
```

Optionally, you can use Terraform functions/expressions to filter the list of bucket names before providing it to `for_each` if channels should only be created for a subset of buckets.

### Managing channel assignment for automatically created channels

Channel assignment for automatically created channels can be managed in many ways. A nonexhaustive example configuration is provided below.

```terraform
data "hcp_packer_version" "all_latest" {
  for_each = data.hcp_packer_bucket_names.all.names

  bucket_name  = each.key
  channel_name = "latest"
}

data "hcp_packer_version" "bucket3_staging" {
  bucket_name  = "bucket3"
  channel_name = "staging"
}

resource "hcp_packer_channel_assignment" "release" {
  for_each = merge(
    { # Defaulting all channels to be unassigned and Terraform-managed
      for bucketName in keys(hcp_packer_channel.release) :
      bucketName => "none"
    },
    { # Assigning channels that match a filter to an version fetched from another channel
      for bucketName in keys(hcp_packer_channel.release) :
      bucketName => data.hcp_packer_version.all_latest[bucketName].fingerprint
      if endswith(bucketName, "-dev")
    },
    { # Individual channel assignments
      "bucket1" : "01H1SF9NWAK8AP25PAWDBGZ1YD"
      "bucket2" : "01H28NJ7WPCZA0FZZ8G3FGGTAF"
      "bucket3" : data.hcp_packer_version.bucket3_staging.fingerprint
    }
  )

  bucket_name = each.key
  # Using a reference for `channel_name` allows it to be generated dynamically
  # in the `hcp_packer_channel.release` resource if desired.
  channel_name = hcp_packer_channel.release[each.key].name

  version_fingerprint = each.value
}
```

You are not required to configure an assignment for every channel at the same time as automatic channel creation. Using Terraform builtin functions/expressions, it is possible to limit which channels should have assignments configured by default.

The default value used in the example is `"none"`, which causes Terraform to set the channel to have no assigned version and continue to ensure that a version is not assigned elsewhere. 

If an invalid bucket name is provided in the `for_each` map, an error will be thrown. This helps to ensure that the configuration doesn't contain orphaned values, but can cause plan failures when buckets are deleted. If this behavior is undesirable, filter out invalid buckets from the result of the `merge` function.

An [example module](https://github.com/hashicorp/terraform-provider-hcp/tree/main/examples/guides/packer_channel_management/bucket_names/example_module) is available that includes options to leave select channels unmanaged, require explicit configurations for select channels, ignore invalid bucket names in the configuration, and automatically assign a version fetched from another channel.




# Adding an HCP Packer Run Task to Terraform Cloud or Terraform Enterprise

You can add an HCP Packer Run Task to Terraform Cloud or Terraform Enterprise
by combining the HCP Terraform Provider and the
[Terraform Cloud/Enterprise Provider](https://registry.terraform.io/providers/hashicorp/tfe).

## Using the `hcp_packer_run_task` Data Source

If the Terraform workspace where this config will live already has an
`hcp_packer_run_task` resource, you should use the resource instead.

```terraform
data "hcp_packer_run_task" "registry" {}

resource "tfe_organization_run_task" "hcp_packer" {
  name        = "HCP_Packer"
  description = "Ensure usage of compliant images from HCP Packer."
  enabled     = true

  url      = data.hcp_packer_run_task.registry.endpoint_url
  hmac_key = data.hcp_packer_run_task.registry.hmac_key
}
```

## Using the `hcp_packer_run_task` Resource

If the Terraform workspace where this config will live does not already have a
`hcp_packer_run_task` resource and you don't need to be able to regenerate the
HMAC Key in that workspace, you should use the data source instead.

```terraform
resource "hcp_packer_run_task" "registry" {
  regenerate_hmac = false
}

resource "tfe_organization_run_task" "hcp_packer" {
  name        = "HCP_Packer"
  description = "Ensure usage of compliant images from HCP Packer."
  enabled     = true

  url      = hcp_packer_run_task.registry.endpoint_url
  hmac_key = hcp_packer_run_task.registry.hmac_key
}
```




# Peer an AWS VPC to a HashiCorp Virtual Network (HVN)

In order to connect AWS workloads to an HCP Consul cluster, you must peer the VPC in which the workloads reside to the HVN in which the HCP cluster resides.
This is accomplished by using the `hcp_aws_network_peering` resource to create a network peering between the HVN's VPC and your own VPC.
The [aws_vpc_peering_connection_accepter](https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/vpc_peering_connection_accepter) resource is useful for accepting the network peering that is initiated from the `hcp_aws_network_peering`.

-> **Note:** The CIDR blocks of the HVN and the peer VPC cannot overlap.

For a complete example of deploying Consul on HCP, check out the [Deploy HCP Consul with Terraform](https://developer.hashicorp.com/consul/tutorials/cloud-production/terraform-hcp-consul-provider) guide.
```terraform
// Create a HashiCorp Virtual Network (HVN).
resource "hcp_hvn" "example" {
  hvn_id         = var.hvn_id
  cloud_provider = "aws"
  region         = var.region
  cidr_block     = "172.25.16.0/20"
}

// Create an HCP Consul cluster within the HVN.
resource "hcp_consul_cluster" "example" {
  hvn_id     = hcp_hvn.example.hvn_id
  cluster_id = var.cluster_id
  tier       = "development"
}

// If you have not already, create a VPC within your AWS account that will
// contain the workloads you want to connect to your HCP Consul cluster.
// Make sure the CIDR block of the peer VPC does not overlap with the CIDR
// of the HVN.
resource "aws_vpc" "peer" {
  cidr_block = "10.220.0.0/16"
}

// Create an HCP network peering to peer your HVN with your AWS VPC. 
// This resource initially returns in a Pending state, because its provider_peering_id is required to complete acceptance of the connection.
resource "hcp_aws_network_peering" "example" {
  peering_id      = var.peer_id
  hvn_id          = hcp_hvn.example.hvn_id
  peer_vpc_id     = aws_vpc.peer.id
  peer_account_id = aws_vpc.peer.owner_id
  peer_vpc_region = var.region
}

// This data source is the same as the resource above, but waits for the connection to be Active before returning.
data "hcp_aws_network_peering" "example" {
  hvn_id                = hcp_hvn.example.hvn_id
  peering_id            = hcp_aws_network_peering.example.peering_id
  wait_for_active_state = true
}

// Accept the VPC peering within your AWS account.
resource "aws_vpc_peering_connection_accepter" "peer" {
  vpc_peering_connection_id = hcp_aws_network_peering.example.provider_peering_id
  auto_accept               = true
}

// Create an HVN route that targets your HCP network peering and matches your AWS VPC's CIDR block.
// The route depends on the data source, rather than the resource, to ensure the peering is in an Active state.
resource "hcp_hvn_route" "example" {
  hvn_link         = hcp_hvn.example.self_link
  hvn_route_id     = var.route_id
  destination_cidr = aws_vpc.peer.cidr_block
  target_link      = data.hcp_aws_network_peering.example.self_link
}
```

## Tutorials

Refer to the following tutorials for additional usage examples:

- [Deploy HCP Consul with Terraform](https://developer.hashicorp.com/consul/tutorials/cloud-production/terraform-hcp-consul-provider)
- [Deploy HCP Vault with Terraform](https://developer.hashicorp.com/vault/tutorials/cloud-ops/terraform-hcp-provider-vault)




# Peer an Azure VNet to a HashiCorp Virtual Network (HVN)

In order to connect Azure workloads to an HCP services, you must peer the VNet in which the workloads reside to the HVN in which the HCP service resides.
This is accomplished by using the `hcp_azure_peering_connection` resource to create a network peering between the HVN's VNet and your own VNet.

-> **Note:** The CIDR blocks of the HVN and the peer VNet cannot overlap.

-> **Note:** The Azure peering must be accepted by adding the HCP-supplied Application/Service Principal ID and associated custom role and role assignment in your Azure tenant. These must be completed by a User or Service Principal with the Azure AD API Permissions described [here](https://registry.terraform.io/providers/hashicorp/azuread/latest/docs/resources/service_principal) and an AzureRM `_Owner_` or `_User Access Administrator_` role assignment over an appropriate scope where your Virtual Network resides. If the peering is not accepted in time or the AzureAD/AzureRM provider principals used with the Terraform config below do not have the appropriate permissions, this deployment will hang until the Terraform Run times out due to the `hcp_azure_peering_connection` data source that waits for the peering to be accepted.

```terraform
provider "azurerm" {
  features {}
}

provider "azuread" {}
provider "hcp" {}

resource "hcp_hvn" "hvn" {
  hvn_id         = "main-hvn"
  cloud_provider = "azure"
  region         = "westus2"
  cidr_block     = "172.25.16.0/20"
}

// This resource initially returns in a Pending state, because its application_id is required to complete acceptance of the connection.
resource "hcp_azure_peering_connection" "peer" {
  hvn_link                 = hcp_hvn.hvn.self_link
  peering_id               = "dev"
  peer_vnet_name           = azurerm_virtual_network.vnet.name
  peer_subscription_id     = azurerm_subscription.sub.subscription_id
  peer_tenant_id           = "<tenant UUID>"
  peer_resource_group_name = azurerm_resource_group.rg.name
  peer_vnet_region         = azurerm_virtual_network.vnet.location
}

// This data source is the same as the resource above, but waits for the connection to be Active before returning.
data "hcp_azure_peering_connection" "peer" {
  hvn_link              = hcp_hvn.hvn.self_link
  peering_id            = hcp_azure_peering_connection.peer.peering_id
  wait_for_active_state = true
}

// The route depends on the data source, rather than the resource, to ensure the peering is in an Active state.
resource "hcp_hvn_route" "route" {
  hvn_link         = hcp_hvn.hvn.self_link
  hvn_route_id     = "azure-route"
  destination_cidr = "172.31.0.0/16"
  target_link      = data.hcp_azure_peering_connection.peer.self_link
}

data "azurerm_subscription" "sub" {
  subscription_id = "<subscription UUID>"
}

resource "azurerm_resource_group" "rg" {
  name     = "resource-group-test"
  location = "West US"
}

resource "azurerm_virtual_network" "vnet" {
  name                = "vnet-test"
  location            = azurerm_resource_group.rg.location
  resource_group_name = azurerm_resource_group.rg.name

  address_space = [
    "10.0.0.0/16"
  ]
}

// The principal deploying the `azuread_service_principal` resource below requires
// API Permissions as described here: https://registry.terraform.io/providers/hashicorp/azuread/latest/docs/resources/service_principal.
// The principal deploying the `azurerm_role_definition` and `azurerm_role_assigment`
// resources must have Owner or User Access Administrator permissions over an appropriate
// scope that includes your Virtual Network.
resource "azuread_service_principal" "principal" {
  application_id = hcp_azure_peering_connection.peer.application_id
}

resource "azurerm_role_definition" "definition" {
  name  = "hcp-hvn-peering-access"
  scope = azurerm_virtual_network.vnet.id

  assignable_scopes = [
    azurerm_virtual_network.vnet.id
  ]

  permissions {
    actions = [
      "Microsoft.Network/virtualNetworks/peer/action",
      "Microsoft.Network/virtualNetworks/virtualNetworkPeerings/read",
      "Microsoft.Network/virtualNetworks/virtualNetworkPeerings/write"
    ]
  }
}

resource "azurerm_role_assignment" "assignment" {
  principal_id       = azuread_service_principal.principal.id
  scope              = azurerm_virtual_network.vnet.id
  role_definition_id = azurerm_role_definition.definition.role_definition_resource_id
}
```

## Peer an Azure VNet to an HVN - Gateway support

The following example shows how to connect Azure workloads to HCP HVNs which require [Hub-spoke network topology](https://learn.microsoft.com/en-us/azure/architecture/reference-architectures/hybrid-networking/hub-spoke?tabs=cli) utilizing an Azure VPN Gateway.

-> **Note:** Azure Hub/Spoke architecture support is in private beta. Please contact [HashiCorp support](https://support.hashicorp.com/hc/en-us) for details.

Notable aspects of this configuration:
* When the `use_remote_gatways` parameter of the `hcp_azure_peering_connection` resource is set to `true`, the peering link from customer VNet to HVN is set with `AllowGatewayTransit` to `true`.

```terraform
terraform {
  required_providers {
    hcp = {
      source  = "hashicorp/hcp"
      version = "~> 0.78.0"
    }
    azurerm = {
      source  = "hashicorp/azurerm"
      version = "=3.0.0"
    }
  }
}

provider "azurerm" {
  features {}
}

variable "subscription_id" {
  type        = string
  description = "The Azure AD Subscription ID"
}

variable "tenant_id" {
  type        = string
  description = "The Azure AD Tenant ID"
}

locals {
  uid             = random_uuid.uuid.result
  short_uid       = format("%.10s", local.uid)
  subscription_id = var.subscription_id
  tenant_id       = var.tenant_id
}

resource "random_uuid" "uuid" {}

resource "hcp_hvn" "hvn" {
  hvn_id         = "hvn-${local.short_uid}"
  cloud_provider = "azure"
  region         = "eastus"
  cidr_block     = "172.25.16.0/20"
}

resource "hcp_azure_peering_connection" "peering" {
  hvn_link                 = hcp_hvn.hvn.self_link
  peering_id               = "pcx-${local.short_uid}"
  peer_subscription_id     = local.subscription_id
  peer_tenant_id           = local.tenant_id
  peer_vnet_name           = azurerm_virtual_network.vnet.name
  peer_resource_group_name = azurerm_resource_group.rg.name
  peer_vnet_region         = "eastus"

  allow_forwarded_traffic = false
  use_remote_gateways     = true
}

// This data source is the same as the resource above, but waits for the connection
// to be Active before returning.
data "hcp_azure_peering_connection" "peering" {
  hvn_link              = hcp_hvn.hvn.self_link
  peering_id            = hcp_azure_peering_connection.peering.peering_id
  wait_for_active_state = true
}

// The route depends on the data source, rather than the resource, to ensure the
// peering is in an Active state.
resource "hcp_hvn_route" "route" {
  hvn_route_id     = "route-${local.short_uid}"
  hvn_link         = hcp_hvn.hvn.self_link
  destination_cidr = "172.31.0.0/16"
  target_link      = data.hcp_azure_peering_connection.peering.self_link

  azure_config {
    next_hop_type = "VIRTUAL_NETWORK_GATEWAY"
  }
}

resource "azurerm_resource_group" "rg" {
  name     = "rg-${local.short_uid}"
  location = "East US"
}

resource "azurerm_virtual_network" "vnet" {
  name                = "vnet-${local.short_uid}"
  location            = azurerm_resource_group.rg.location
  resource_group_name = azurerm_resource_group.rg.name

  address_space = [
    "10.0.0.0/16"
  ]
}

resource "azurerm_subnet" "subnet" {
  name                 = "GatewaySubnet"
  resource_group_name  = azurerm_resource_group.rg.name
  virtual_network_name = azurerm_virtual_network.vnet.name

  address_prefixes = [
    "10.0.1.0/24"
  ]
}

resource "azurerm_public_ip" "ip" {
  name                = "ip-${local.short_uid}"
  location            = azurerm_resource_group.rg.location
  resource_group_name = azurerm_resource_group.rg.name
  allocation_method   = "Dynamic"
}

resource "azurerm_virtual_network_gateway" "gateway" {
  name                = "gateway-${local.short_uid}"
  location            = azurerm_resource_group.rg.location
  resource_group_name = azurerm_resource_group.rg.name
  type                = "Vpn"
  vpn_type            = "RouteBased"
  enable_bgp          = false // Explicit; defaults to false
  sku                 = "Basic"

  ip_configuration {
    name                          = "ipconf-${local.short_uid}"
    public_ip_address_id          = azurerm_public_ip.ip.id
    private_ip_address_allocation = "Dynamic"
    subnet_id                     = azurerm_subnet.subnet.id
  }
}

// The principal deploying the `azuread_service_principal` resource below requires
// API Permissions as described here: https://registry.terraform.io/providers/hashicorp/azuread/latest/docs/resources/service_principal.
// The principal deploying the `azurerm_role_definition` and `azurerm_role_assigment`
// resources must have Owner or User Access Administrator permissions over an appropriate
// scope that includes your Virtual Network.
resource "azuread_service_principal" "principal" {
  application_id = hcp_azure_peering_connection.peering.application_id
}

resource "azurerm_role_definition" "definition" {
  name  = "hcp-provider-test-role-def"
  scope = azurerm_virtual_network.vnet.id

  assignable_scopes = [
    azurerm_virtual_network.vnet.id
  ]

  permissions {
    actions = [
      "Microsoft.Network/virtualNetworks/peer/action",
      "Microsoft.Network/virtualNetworks/virtualNetworkPeerings/read",
      "Microsoft.Network/virtualNetworks/virtualNetworkPeerings/write"
    ]
  }
}

resource "azurerm_role_assignment" "assignment" {
  principal_id       = azuread_service_principal.principal.id
  scope              = azurerm_virtual_network.vnet.id
  role_definition_id = azurerm_role_definition.definition.role_definition_resource_id
}
```

## Peer an Azure VNet to an HVN - Network Virtual Appliance (NVA) support

The following example shows how to connect Azure workloads to HCP HVNs which require [Hub-spoke network topology](https://learn.microsoft.com/en-us/azure/architecture/reference-architectures/hybrid-networking/hub-spoke?tabs=cli) utilizing an Azure Network Virtual Appliance.

-> **Note:** Azure Hub/Spoke architecture support is in private beta. Please contact [HashiCorp support](https://support.hashicorp.com/hc/en-us) for details.

Notable aspects of this configuration:
* An Azure Firewall is used as the Network Virtual Appliance (NVA).
* A "Spoke" Virtual Network is included and peered to the "Hub" Virtual Network.

```terraform
terraform {
  required_providers {
    hcp = {
      source  = "hashicorp/hcp"
      version = "~> 0.78.0"
    }
    azurerm = {
      source  = "hashicorp/azurerm"
      version = "=3.0.0"
    }
  }
}

provider "azurerm" {
  features {}
}

variable "subscription_id" {
  type        = string
  description = "The Azure AD Subscription ID"
}

variable "tenant_id" {
  type        = string
  description = "The Azure AD Tenant ID"
}

locals {
  uid             = random_uuid.uuid.result
  short_uid       = format("%.10s", local.uid)
  subscription_id = var.subscription_id
  tenant_id       = var.tenant_id
  cidr            = "172.25.16.0/20"
}

resource "random_uuid" "uuid" {}

resource "hcp_hvn" "hvn" {
  hvn_id         = "hvn-${local.short_uid}"
  cloud_provider = "azure"
  region         = "eastus"
  cidr_block     = local.cidr
}

resource "hcp_azure_peering_connection" "peering" {
  hvn_link                 = hcp_hvn.hvn.self_link
  peering_id               = "pcx-${local.short_uid}"
  peer_subscription_id     = local.subscription_id
  peer_tenant_id           = local.tenant_id
  peer_vnet_name           = azurerm_virtual_network.vnet.name
  peer_resource_group_name = azurerm_resource_group.rg.name
  peer_vnet_region         = "eastus"

  allow_forwarded_traffic = true
  use_remote_gateways     = false
}

// This data source is the same as the resource above, but waits for the connection
// to be Active before returning.
data "hcp_azure_peering_connection" "peering" {
  hvn_link              = hcp_hvn.hvn.self_link
  peering_id            = hcp_azure_peering_connection.peering.peering_id
  wait_for_active_state = true
}

// The route depends on the data source, rather than the resource, to ensure the
// peering is in an Active state.
resource "hcp_hvn_route" "route" {
  hvn_route_id     = "route-${local.short_uid}"
  hvn_link         = hcp_hvn.hvn.self_link
  destination_cidr = azurerm_virtual_network.spoke.address_space[0]
  target_link      = data.hcp_azure_peering_connection.peering.self_link

  azure_config {
    next_hop_type       = "VIRTUAL_APPLIANCE"
    next_hop_ip_address = azurerm_firewall.firewall.ip_configuration[0].private_ip_address
  }
}

resource "azurerm_resource_group" "rg" {
  name     = "rg-${local.short_uid}"
  location = "East US"
}

resource "azurerm_virtual_network" "vnet" {
  name                = "vnet-${local.short_uid}"
  location            = azurerm_resource_group.rg.location
  resource_group_name = azurerm_resource_group.rg.name

  address_space = [
    "10.0.0.0/16"
  ]
}

resource "azurerm_subnet" "spoke" {
  name                 = "subnet-spoke-${local.short_uid}"
  resource_group_name  = azurerm_resource_group.rg.name
  virtual_network_name = azurerm_virtual_network.spoke.name

  address_prefixes = [
    "10.1.0.0/24"
  ]
}

resource "azurerm_virtual_network" "spoke" {
  name                = "vnet-spoke-${local.short_uid}"
  location            = azurerm_resource_group.rg.location
  resource_group_name = azurerm_resource_group.rg.name

  address_space = [
    "10.1.0.0/16"
  ]
}

resource "azurerm_route_table" "spoke" {
  name                = "rtab-spoke-${local.short_uid}"
  location            = azurerm_resource_group.rg.location
  resource_group_name = azurerm_resource_group.rg.name

  disable_bgp_route_propagation = false
}

resource "azurerm_subnet_route_table_association" "spoke" {
  subnet_id      = azurerm_subnet.spoke.id
  route_table_id = azurerm_route_table.spoke.id
}

resource "azurerm_route" "spoke" {
  name                = "route-spoke-${local.short_uid}"
  resource_group_name = azurerm_resource_group.rg.name
  route_table_name    = azurerm_route_table.spoke.name

  address_prefix         = local.cidr
  next_hop_type          = "VirtualAppliance"
  next_hop_in_ip_address = azurerm_firewall.firewall.ip_configuration[0].private_ip_address
}

resource "azurerm_subnet" "firewall" {
  name                 = "AzureFirewallSubnet"
  resource_group_name  = azurerm_resource_group.rg.name
  virtual_network_name = azurerm_virtual_network.vnet.name

  address_prefixes = [
    "10.0.255.0/24"
  ]
}

resource "azurerm_firewall" "firewall" {
  name                = "firewall-${local.short_uid}"
  location            = azurerm_resource_group.rg.location
  resource_group_name = azurerm_resource_group.rg.name

  sku_name = "AZFW_VNet"
  sku_tier = "Standard"

  ip_configuration {
    name                 = "firewall-conf-${local.short_uid}"
    subnet_id            = azurerm_subnet.firewall.id
    public_ip_address_id = azurerm_public_ip.firewall.id
  }
}


resource "azurerm_public_ip" "firewall" {
  name                = "firewall-ip-${local.short_uid}"
  location            = azurerm_resource_group.rg.location
  resource_group_name = azurerm_resource_group.rg.name
  allocation_method   = "Static"
  sku                 = "Standard"
}

resource "azurerm_firewall_network_rule_collection" "firewall" {
  name                = "firewall-collection-${local.short_uid}"
  resource_group_name = azurerm_resource_group.rg.name
  azure_firewall_name = azurerm_firewall.firewall.name
  priority            = 100
  action              = "Allow"

  rule {
    name                  = "HNVtoSpoke"
    protocols             = ["Any"]
    source_addresses      = [hcp_hvn.hvn.cidr_block]
    destination_addresses = azurerm_virtual_network.spoke.address_space
    destination_ports     = ["*"]
  }

  rule {
    name                  = "SpokeToHVN"
    protocols             = ["Any"]
    source_addresses      = azurerm_virtual_network.spoke.address_space
    destination_addresses = [hcp_hvn.hvn.cidr_block]
    destination_ports     = ["*"]
  }
}

resource "azurerm_virtual_network_peering" "firewall_spoketohub" {
  name                = "peering-sth-${local.short_uid}"
  resource_group_name = azurerm_resource_group.rg.name

  virtual_network_name         = azurerm_virtual_network.spoke.name
  remote_virtual_network_id    = azurerm_virtual_network.vnet.id
  allow_virtual_network_access = true
  allow_forwarded_traffic      = true
  allow_gateway_transit        = false
  use_remote_gateways          = false
}

resource "azurerm_virtual_network_peering" "firewall_hubtospoke" {
  name                = "peering-hts-${local.short_uid}"
  resource_group_name = azurerm_resource_group.rg.name

  virtual_network_name         = azurerm_virtual_network.vnet.name
  remote_virtual_network_id    = azurerm_virtual_network.spoke.id
  allow_virtual_network_access = true
  allow_forwarded_traffic      = false
  allow_gateway_transit        = false
  use_remote_gateways          = false
}

// The principal deploying the `azuread_service_principal` resource below requires
// API Permissions as described here: https://registry.terraform.io/providers/hashicorp/azuread/latest/docs/resources/service_principal.
// The principal deploying the `azurerm_role_definition` and `azurerm_role_assigment`
// resources must have Owner or User Access Administrator permissions over an appropriate
// scope that includes your Virtual Network.
resource "azuread_service_principal" "principal" {
  application_id = hcp_azure_peering_connection.peering.application_id
}

resource "azurerm_role_definition" "definition" {
  name  = "hcp-provider-test-role-def"
  scope = azurerm_virtual_network.vnet.id

  assignable_scopes = [
    azurerm_virtual_network.vnet.id
  ]

  permissions {
    actions = [
      "Microsoft.Network/virtualNetworks/peer/action",
      "Microsoft.Network/virtualNetworks/virtualNetworkPeerings/read",
      "Microsoft.Network/virtualNetworks/virtualNetworkPeerings/write"
    ]
  }
}

resource "azurerm_role_assignment" "assignment" {
  principal_id       = azuread_service_principal.principal.id
  scope              = azurerm_virtual_network.vnet.id
  role_definition_id = azurerm_role_definition.definition.role_definition_resource_id
}
```

## Tutorials

Refer to the following tutorials for additional usage examples:

- [Configure Azure VM for HCP](https://developer.hashicorp.com/consul/tutorials/cloud-production/consul-client-azure-virtual-machines)




# hcp_project (Resource)

The project resource manages a HCP Project.

The user or service account that is running Terraform when creating a `hcp_project` resource must have `roles/admin` on the specified organization.

## Example Usage

```terraform
resource "hcp_project" "example" {
  name        = "example-project"
  description = "My new project!"
}
```

<!-- schema generated by tfplugindocs -->
## Schema

### Required

- `name` (String) The project's name.

### Optional

- `description` (String) The project's description

### Read-Only

- `resource_id` (String) The project's unique identifier
- `resource_name` (String) The project's resource name in format "project/<resource_id>"

## Import

Import is supported using the following syntax:

```shell
# Project can be imported by specifying the project id
terraform import hcp_project.example 840e3701-55b6-4f86-8c17-b1fe397303c5
```




# hcp_project_iam_binding (Resource)

Updates the project's IAM policy to bind a role to a new member. Existing bindings are preserved.

~> **Note:** `hcp_project_iam_binding` can not be used in conjunction with
`hcp_project_iam_policy`.

## Example Usage

```terraform
resource "hcp_project" "example" {
  name = "example"
}

resource "hcp_service_principal" "sp" {
  name   = "example-sp"
  parent = hcp_project.example.resource_name
}

resource "hcp_project_iam_binding" "example" {
  project_id   = hcp_project.example.resource_id
  principal_id = hcp_service_principal.sp.resource_id
  role         = "roles/contributor"
}
```

<!-- schema generated by tfplugindocs -->
## Schema

### Required

- `principal_id` (String) The principal to bind to the given role.
- `role` (String) The role name to bind to the given principal.

### Optional

- `project_id` (String) The ID of the HCP project to apply the IAM Policy to. If unspecified, the project configured on the provider is used.




# hcp_project_iam_policy (Resource)

!> **Be Careful!** You can accidentally lock yourself out of your project using
this resource. Deleting a hcp_project_iam_policy removes access from anyone
without organization-level access to the project. It is not recommended to use
hcp_project_iam_policy with your provider project to avoid locking yourself out,
and it should generally only be used with projects fully managed by Terraform.
If you are trying to additively give permissions to the project, prefer using
`hcp_project_iam_binding`. If you do use this resource, it is recommended to
import the policy before applying the change.

Sets the project's IAM policy and replaces any existing policy.

~> **Note:** `hcp_project_iam_policy` can not be used in conjunction with
`hcp_project_iam_binding`.

## Example Usage

```terraform
data "hcp_iam_policy" "example" {
  bindings = [
    {
      role = "roles/contributor"
      principals = [
        "example-user-id-1",
        "example-group-id-1",
        "example-sp-1"
      ]
    },
  ]
}

resource "hcp_project" "my_project" {
  name = "example"
}

resource "hcp_project_iam_policy" "project_policy" {
  project_id  = hcp_project.my_project.resource_id
  policy_data = data.hcp_iam_policy.example.policy_data
}
```

<!-- schema generated by tfplugindocs -->
## Schema

### Required

- `policy_data` (String) The policy to apply.

### Optional

- `project_id` (String) The ID of the HCP project to apply the IAM Policy to. If unspecified, the project configured on the provider is used.

### Read-Only

- `etag` (String) The etag captures the existing state of the policy.

## Import

Import is supported using the following syntax:

```shell
# Project IAM Policy can be imported by specifying the project id
terraform import hcp_project_iam_policy.example 840e3701-55b6-4f86-8c17-b1fe397303c5
```




# hcp_service_principal (Resource)

The service principal resource manages a HCP Service Principal.

The user or service account that is running Terraform when creating a `hcp_service_principal` resource must have `roles/admin` on the parent resource; either the project or organization.

## Example Usage: Create in provider configured project

```terraform
resource "hcp_service_principal" "example" {
  name = "example-sp"
}
```

## Example Usage: Create in new project

```terraform
resource "hcp_project" "my_proj" {
  name = "example"
}

resource "hcp_service_principal" "example" {
  name   = "example-sp"
  parent = hcp_project.my_proj.resource_name
}
```

## Example Usage: Create organization service principal

```terraform
data "hcp_organization" "my_org" {
}

resource "hcp_service_principal" "example" {
  name   = "example-sp"
  parent = data.hcp_organization.my_org.resource_name
}
```

<!-- schema generated by tfplugindocs -->
## Schema

### Required

- `name` (String) The service principal's name.

### Optional

- `parent` (String) The parent location to create the service principal under. If unspecified, the service principal will be created in the project the provider is configured with. If specified, the accepted values are "project/<project_id>" or "organization/<organization_id>"

### Read-Only

- `resource_id` (String) The service principal's unique identifier
- `resource_name` (String) The service principal's resource name in the format `iam/project/<project_id>/service-principal/<name>` or `iam/organization/<organization_id>/service-principal/<name>`

## Import

Import is supported using the following syntax:

```shell
# Service Principals can be imported by specifying the resource name
terraform import hcp_service_principal.example iam/project/840e3701-55b6-4f86-8c17-b1fe397303c5/service-principal/my-sp
```




# hcp_service_principal_key (Resource)

The service principal key resource manages a service principal key.

The user or service account that is running Terraform when creating a `hcp_service_principal_key` resource must have `roles/admin` on the parent resource; either the project or organization.

## Example Usage: Creating a new key

```terraform
resource "hcp_service_principal" "example" {
  name = "example-sp"
}

resource "hcp_service_principal_key" "key" {
  service_principal = hcp_service_principal.example.resource_name
}
```

## Example Usage: Creating and regularly rotating a key

```terraform
resource "hcp_service_principal" "example" {
  name = "example-sp"
}

# Note this requires the Terraform to be run regularly
resource "time_rotating" "key_rotation" {
  rotation_days = 14
}

resource "hcp_service_principal_key" "key" {
  service_principal = hcp_service_principal.example.resource_name
  rotation_triggers {
    rotation_time = time_rotating.key_rotation.rotation_rfc3339
  }
}
```

<!-- schema generated by tfplugindocs -->
## Schema

### Required

- `service_principal` (String) The service principal's resource name for which a key should be created.

### Optional

- `rotate_triggers` (Map of String) A map of arbitrary string key/value pairs that will force recreation of the key when they change, enabling key based on external conditions such as a rotating timestamp. Changing this forces a new resource to be created.

### Read-Only

- `client_id` (String) The generated service principal client_id.
- `client_secret` (String, Sensitive) The generated service principal client_secret.
- `resource_name` (String) The service principal key's resource name.




# hcp_user_principal (Data Source)

The user principal data source retrieves the given user principal.

## Example Usage

```terraform
data "hcp_user_principal" "example" {
  user_id = var.example_user_id
}

data "hcp_user_principal" "example" {
  email = var.example_email
}
```

<!-- schema generated by tfplugindocs -->
## Schema

### Optional

- `email` (String) The user's email. Can not be combined with user_id.
- `user_id` (String) The user's unique identifier. Can not be combined with email.




# hcp_vault_cluster (Resource)

The Vault cluster resource allows you to manage an HCP Vault cluster.

-> **Note:** It is recommended to set `lifecycle { prevent_destroy = true }` on production Vault instances to prevent accidental cluster deletion. This setting rejects plans that would destroy the cluster, such as attempting to change the `hvn_id`. Read more about it in the [Terraform docs](https://www.terraform.io/language/meta-arguments/lifecycle#prevent_destroy).

## Example Usage

```terraform
resource "hcp_hvn" "example" {
  hvn_id         = "hvn"
  cloud_provider = "aws"
  region         = "us-west-2"
  cidr_block     = "172.25.16.0/20"
}

resource "hcp_vault_cluster" "example" {
  cluster_id = "vault-cluster"
  hvn_id     = hcp_hvn.example.hvn_id
  tier       = "standard_large"
  metrics_config {
    datadog_api_key = "test_datadog"
    datadog_region  = "us1"
  }
  audit_log_config {
    datadog_api_key = "test_datadog"
    datadog_region  = "us1"
  }
  lifecycle {
    prevent_destroy = true
  }
}
```

<!-- schema generated by tfplugindocs -->
## Schema

### Required

- `cluster_id` (String) The ID of the HCP Vault cluster.
- `hvn_id` (String) The ID of the HVN this HCP Vault cluster is associated to.

### Optional

- `audit_log_config` (Block List, Max: 1) The audit logs configuration for export. (https://developer.hashicorp.com/vault/tutorials/cloud-monitoring/vault-metrics-guide#metrics-streaming-configuration) (see [below for nested schema](#nestedblock--audit_log_config))
- `ip_allowlist` (Block List, Max: 50) Allowed IPV4 address ranges (CIDRs) for inbound traffic. Each entry must be a unique CIDR. Maximum 50 CIDRS supported at this time. (see [below for nested schema](#nestedblock--ip_allowlist))
- `major_version_upgrade_config` (Block List, Max: 1) The Major Version Upgrade configuration. (see [below for nested schema](#nestedblock--major_version_upgrade_config))
- `metrics_config` (Block List, Max: 1) The metrics configuration for export. (https://developer.hashicorp.com/vault/tutorials/cloud-monitoring/vault-metrics-guide#metrics-streaming-configuration) (see [below for nested schema](#nestedblock--metrics_config))
- `min_vault_version` (String) The minimum Vault version to use when creating the cluster. If not specified, it is defaulted to the version that is currently recommended by HCP.
- `paths_filter` (List of String) The performance replication [paths filter](https://developer.hashicorp.com/vault/tutorials/cloud-ops/vault-replication-terraform). Applies to performance replication secondaries only and operates in "deny" mode only.
- `primary_link` (String) The `self_link` of the HCP Vault Plus tier cluster which is the primary in the performance replication setup with this HCP Vault Plus tier cluster. If not specified, it is a standalone Plus tier HCP Vault cluster.
- `project_id` (String) The ID of the HCP project where the Vault cluster is located.
If not specified, the project specified in the HCP Provider config block will be used, if configured.
If a project is not configured in the HCP Provider config block, the oldest project in the organization will be used.
- `proxy_endpoint` (String) Denotes that the cluster has a proxy endpoint. Valid options are `ENABLED`, `DISABLED`. Defaults to `DISABLED`.
- `public_endpoint` (Boolean) Denotes that the cluster has a public endpoint. Defaults to false.
- `tier` (String) Tier of the HCP Vault cluster. Valid options for tiers - `dev`, `standard_small`, `standard_medium`, `standard_large`, `plus_small`, `plus_medium`, `plus_large`. See [pricing information](https://www.hashicorp.com/products/vault/pricing). Changing a cluster's size or tier is only available to admins. See [Scale a cluster](https://registry.terraform.io/providers/hashicorp/hcp/latest/docs/guides/vault-scaling).
- `timeouts` (Block, Optional) (see [below for nested schema](#nestedblock--timeouts))

### Read-Only

- `cloud_provider` (String) The provider where the HCP Vault cluster is located.
- `created_at` (String) The time that the Vault cluster was created.
- `id` (String) The ID of this resource.
- `namespace` (String) The name of the customer namespace this HCP Vault cluster is located in.
- `organization_id` (String) The ID of the organization this HCP Vault cluster is located in.
- `region` (String) The region where the HCP Vault cluster is located.
- `self_link` (String) A unique URL identifying the Vault cluster.
- `state` (String) The state of the Vault cluster.
- `vault_private_endpoint_url` (String) The private URL for the Vault cluster.
- `vault_proxy_endpoint_url` (String) The proxy URL for the Vault cluster. This will be empty if `proxy_endpoint` is `DISABLED`.
- `vault_public_endpoint_url` (String) The public URL for the Vault cluster. This will be empty if `public_endpoint` is `false`.
- `vault_version` (String) The Vault version of the cluster.

<a id="nestedblock--audit_log_config"></a>
### Nested Schema for `audit_log_config`

Optional:

- `cloudwatch_access_key_id` (String) CloudWatch access key ID for streaming audit logs
- `cloudwatch_region` (String) CloudWatch region for streaming audit logs
- `cloudwatch_secret_access_key` (String, Sensitive) CloudWatch secret access key for streaming audit logs
- `datadog_api_key` (String, Sensitive) Datadog api key for streaming audit logs
- `datadog_region` (String) Datadog region for streaming audit logs
- `elasticsearch_endpoint` (String) ElasticSearch endpoint for streaming audit logs
- `elasticsearch_password` (String, Sensitive) ElasticSearch password for streaming audit logs
- `elasticsearch_user` (String) ElasticSearch user for streaming audit logs
- `grafana_endpoint` (String) Grafana endpoint for streaming audit logs
- `grafana_password` (String, Sensitive) Grafana password for streaming audit logs
- `grafana_user` (String) Grafana user for streaming audit logs
- `http_basic_password` (String, Sensitive) HTTP basic authentication password for streaming audit logs, one of the two available authentication methods, can be specified only if http_basic_user is also provided
- `http_basic_user` (String) HTTP basic authentication username for streaming audit logs, one of the two available authentication methods, can be specified only if http_basic_password is also provided
- `http_bearer_token` (String, Sensitive) HTTP bearer authentication token for streaming audit logs, one of the two available authentication methods, can be specified only if http_basic_user and http_basic_password are not provided
- `http_codec` (String) HTTP codec for streaming audit logs, allowed values are JSON and NDJSON
- `http_compression` (Boolean) HTTP compression flag for streaming audit logs
- `http_headers` (Map of String) HTTP headers for streaming audit logs
- `http_method` (String) HTTP payload method for streaming audit logs, , allowed values are PATCH, POST, or PUT
- `http_payload_prefix` (String) HTTP payload prefix for streaming audit logs
- `http_payload_suffix` (String) HTTP payload suffix for streaming audit logs
- `http_uri` (String) HTTP URI for streaming audit logs
- `newrelic_account_id` (String) NewRelic Account ID for streaming audit logs
- `newrelic_license_key` (String, Sensitive) NewRelic license key for streaming audit logs
- `newrelic_region` (String) NewRelic region for streaming audit logs, allowed values are "US" and "EU"
- `splunk_hecendpoint` (String) Splunk endpoint for streaming audit logs
- `splunk_token` (String, Sensitive) Splunk token for streaming audit logs

Read-Only:

- `cloudwatch_group_name` (String) CloudWatch group name of the target log stream for audit logs
- `cloudwatch_stream_name` (String) CloudWatch stream name for the target log stream for audit logs
- `elasticsearch_dataset` (String) ElasticSearch dataset for streaming audit logs


<a id="nestedblock--ip_allowlist"></a>
### Nested Schema for `ip_allowlist`

Required:

- `address` (String) IP address range in CIDR notation.

Optional:

- `description` (String) Description to help identify source (maximum 255 chars).


<a id="nestedblock--major_version_upgrade_config"></a>
### Nested Schema for `major_version_upgrade_config`

Required:

- `upgrade_type` (String) The major upgrade type for the cluster. Valid options for upgrade type - `AUTOMATIC`, `SCHEDULED`, `MANUAL`

Optional:

- `maintenance_window_day` (String) The maintenance day of the week for scheduled upgrades. Valid options for maintenance window day - `MONDAY`, `TUESDAY`, `WEDNESDAY`, `THURSDAY`, `FRIDAY`, `SATURDAY`, `SUNDAY`
- `maintenance_window_time` (String) The maintenance time frame for scheduled upgrades. Valid options for maintenance window time - `WINDOW_12AM_4AM`, `WINDOW_6AM_10AM`, `WINDOW_12PM_4PM`, `WINDOW_6PM_10PM`


<a id="nestedblock--metrics_config"></a>
### Nested Schema for `metrics_config`

Optional:

- `cloudwatch_access_key_id` (String) CloudWatch access key ID for streaming metrics
- `cloudwatch_region` (String) CloudWatch region for streaming metrics
- `cloudwatch_secret_access_key` (String, Sensitive) CloudWatch secret access key for streaming metrics
- `datadog_api_key` (String, Sensitive) Datadog api key for streaming metrics
- `datadog_region` (String) Datadog region for streaming metrics
- `elasticsearch_endpoint` (String) ElasticSearch endpoint for streaming metrics
- `elasticsearch_password` (String, Sensitive) ElasticSearch password for streaming metrics
- `elasticsearch_user` (String) ElasticSearch user for streaming metrics
- `grafana_endpoint` (String) Grafana endpoint for streaming metrics
- `grafana_password` (String, Sensitive) Grafana password for streaming metrics
- `grafana_user` (String) Grafana user for streaming metrics
- `http_basic_password` (String) HTTP basic authentication password for streaming metrics, one of the two available authentication methods, can be specified only if http_basic_user is also specified
- `http_basic_user` (String) HTTP basic authentication username for streaming metrics, one of the two available authentication methods, can be specified only if http_basic_password is also specified
- `http_bearer_token` (String, Sensitive) HTTP bearer authentication token for streaming metrics, one of the two available authentication methods, can be specified only if http_basic_user and http_basic_password are not provided
- `http_codec` (String) HTTP codec for streaming metrics, allowed values are JSON and NDJSON
- `http_compression` (Boolean) HTTP compression flag for streaming metrics
- `http_headers` (Map of String) HTTP headers for streaming metrics
- `http_method` (String) HTTP payload method for streaming metrics, allowed values are PATCH, POST, or PUT
- `http_payload_prefix` (String) HTTP payload prefix for streaming metrics
- `http_payload_suffix` (String) HTTP payload suffix for streaming metrics
- `http_uri` (String) HTTP URI for streaming metrics
- `newrelic_account_id` (String) NewRelic Account ID for streaming metrics
- `newrelic_license_key` (String, Sensitive) NewRelic license key for streaming metrics
- `newrelic_region` (String) NewRelic region for streaming metrics, allowed values are "US" and "EU"
- `splunk_hecendpoint` (String) Splunk endpoint for streaming metrics
- `splunk_token` (String, Sensitive) Splunk token for streaming metrics

Read-Only:

- `cloudwatch_namespace` (String) CloudWatch namespace for streaming metrics
- `elasticsearch_dataset` (String) ElasticSearch dataset for streaming metrics


<a id="nestedblock--timeouts"></a>
### Nested Schema for `timeouts`

Optional:

- `create` (String)
- `default` (String)
- `delete` (String)
- `update` (String)

-> **Note:** When establishing performance replication links between clusters in different HVNs, an HVN peering connection is required. This can be defined explicitly using an [`hcp_hvn_peering_connection`](hvn_peering_connection.md), or HCP will create the connection automatically (peering connections can be imported after creation using [terraform import](https://www.terraform.io/cli/import)). Note HVN peering [CIDR block requirements](https://cloud.hashicorp.com/docs/hcp/network/routes#cidr-block-requirements).

## Import

Import is supported using the following syntax:

```shell
# Using an explicit project ID, the import ID is:
# {project_id}:{cluster_id}
terraform import hcp_vault_cluster.example f709ec73-55d4-46d8-897d-816ebba28778:vault-cluster
# Using the provider-default project ID, the import ID is:
# {cluster_id}
terraform import hcp_vault_cluster.example vault-cluster
```

## Tutorials

Refer to the following tutorials for additional usage examples:

- [Deploy HCP Vault with Terraform](https://developer.hashicorp.com/vault/tutorials/cloud-ops/terraform-hcp-provider-vault) 
- [Deploy HCP Vault Performance Replication with Terraform](https://developer.hashicorp.com/vault/tutorials/cloud-ops/vault-replication-terraform)




# hcp_vault_cluster_admin_token (Resource)

~> **Security Notice:** Please see this [list of recommendations](https://www.terraform.io/docs/language/state/sensitive-data.html) for storing sensitive information in Terraform.

~> **Known Issue:** An admin token may be generated during a `terraform plan` if the current token is expiring. 
Since the Plan phase does not save any state, the Apply phase saves a different generated token, and the token generated during Plan ends up orphaned. 
It will expire in six hours.

The Vault cluster admin token resource generates an admin-level token for the HCP Vault cluster.

This resource saves a single admin token per Vault cluster and auto-refreshes the token when it is about to expire.
Destroying this resource *does not* invalidate the admin token.

## Example Usage

```terraform
resource "hcp_vault_cluster_admin_token" "example" {
  cluster_id = "test-vault-cluster"
}
```

<!-- schema generated by tfplugindocs -->
## Schema

### Required

- `cluster_id` (String) The ID of the HCP Vault cluster.

### Optional

- `project_id` (String) The ID of the HCP project where the HCP Vault cluster is located. 
If not specified, the project specified in the HCP Provider config block will be used, if configured.
If a project is not configured in the HCP Provider config block, the oldest project in the organization will be used.
- `timeouts` (Block, Optional) (see [below for nested schema](#nestedblock--timeouts))

### Read-Only

- `created_at` (String) The time that the admin token was created.
- `id` (String) The ID of this resource.
- `token` (String, Sensitive) The admin token of this HCP Vault cluster.

<a id="nestedblock--timeouts"></a>
### Nested Schema for `timeouts`

Optional:

- `create` (String)
- `delete` (String)
- `read` (String)




# hcp_vault_plugin (Resource)

The Vault plugin resource allows you to manage an HCP Vault plugin.

<!-- schema generated by tfplugindocs -->
## Schema

### Required

- `cluster_id` (String) The ID of the HCP Vault cluster.
- `plugin_name` (String) The name of the plugin - Valid options for plugin name - 'venafi-pki-backend'
- `plugin_type` (String) The type of the plugin - Valid options for plugin type - 'SECRET', 'AUTH', 'DATABASE'

### Optional

- `project_id` (String) The ID of the HCP project where the HCP Vault cluster is located. 
If not specified, the project specified in the HCP Provider config block will be used, if configured.
If a project is not configured in the HCP Provider config block, the oldest project in the organization will be used.
- `timeouts` (Block, Optional) (see [below for nested schema](#nestedblock--timeouts))

### Read-Only

- `id` (String) The ID of this resource.

<a id="nestedblock--timeouts"></a>
### Nested Schema for `timeouts`

Optional:

- `default` (String)




# hcp_vault_radar_integration_jira_connection (Resource)

-> **Note:** This feature is currently in private beta.

This terraform resource manages an Integration Jira Connection in Vault Radar.

## Example Usage

```terraform
variable "jira_token" {
  type      = string
  sensitive = true
}

resource "hcp_vault_radar_integration_jira_connection" "jira_connection" {
  name     = "example connection to jira"
  email    = "jane.smith@example.com"
  token    = var.jira_token
  base_url = "https://example.atlassian.net"
}
```


<!-- schema generated by tfplugindocs -->
## Schema

### Required

- `base_url` (String) The Jira base URL. Example: https://acme.atlassian.net
- `email` (String, Sensitive) Jira user's email.
- `name` (String) Name of connection. Name must be unique.
- `token` (String, Sensitive) A Jira API token.

### Optional

- `project_id` (String) The ID of the HCP project where Vault Radar is located. If not specified, the project specified in the HCP Provider config block will be used, if configured.

### Read-Only

- `id` (String) The ID of this resource.




# hcp_vault_radar_integration_jira_subscription (Resource)

-> **Note:** This feature is currently in private beta.

This terraform resource manages an Integration Jira Subscription in Vault Radar.

## Example Usage

```terraform
variable "jira_token" {
  type      = string
  sensitive = true
}

# A Jira subscription requires a Jira connection.
resource "hcp_vault_radar_integration_jira_connection" "jira_connection" {
  name     = "example integration jira connection"
  email    = "jane.smith@example.com"
  token    = var.jira_token
  base_url = "https://example.atlassian.net"
}

resource "hcp_vault_radar_integration_jira_subscription" "jira_subscription" {
  name             = "example integration jira subscription"
  connection_id    = hcp_vault_radar_integration_jira_connection.jira_connection.id
  jira_project_key = "SEC"
  issue_type       = "Task"
  assignee         = "71509:11bb945b-c0de-4bac-9d57-9f09db2f7bc9"
  message          = "Example message"
}
```


<!-- schema generated by tfplugindocs -->
## Schema

### Required

- `connection_id` (String) id of the integration jira connection to use for the subscription.
- `issue_type` (String) The type of issue to be created from the event(s). Example: Task
- `jira_project_key` (String) The name of the project under which the jira issue will be created. Example: OPS
- `name` (String) Name of subscription. Name must be unique.

### Optional

- `assignee` (String) The identifier of the Jira user who will be assigned the ticket. In case of Jira Cloud, this will be the Atlassian Account ID of the user. Example: 71509:11bb945b-c0de-4bac-9d57-9f09db2f7bc9
- `message` (String) This message will be included in the ticket description.
- `project_id` (String) The ID of the HCP project where Vault Radar is located. If not specified, the project specified in the HCP Provider config block will be used, if configured.

### Read-Only

- `id` (String) The ID of this resource.




# hcp_vault_radar_integration_slack_connection (Resource)

-> **Note:** This feature is currently in private beta.

This terraform resource manages an Integration Slack Connection in Vault Radar.

## Example Usage

```terraform
variable "slack_token" {
  type      = string
  sensitive = true
}

resource "hcp_vault_radar_integration_slack_connection" "slack_connection" {
  name  = "example connection to slack"
  token = var.slack_token
}
```


<!-- schema generated by tfplugindocs -->
## Schema

### Required

- `name` (String) Name of connection. Name must be unique.
- `token` (String, Sensitive) Slack bot user OAuth token. Example: Bot token strings begin with 'xoxb'.

### Optional

- `project_id` (String) The ID of the HCP project where Vault Radar is located. If not specified, the project specified in the HCP Provider config block will be used, if configured.

### Read-Only

- `id` (String) The ID of this resource.




# hcp_vault_radar_integration_slack_subscription (Resource)

-> **Note:** This feature is currently in private beta.

This terraform resource manages an Integration Slack Subscription in Vault Radar.

## Example Usage

```terraform
variable "slack_token" {
  type      = string
  sensitive = true
}

# A Slack subscription requires a Slack connection.
resource "hcp_vault_radar_integration_slack_connection" "slack_connection" {
  name  = "example connection to slack"
  token = var.slack_token
}

resource "hcp_vault_radar_integration_slack_subscription" "slack_subscription" {
  name          = "example integration slack subscription"
  connection_id = hcp_vault_radar_integration_slack_connection.slack_connection.id
  channel       = "sec-ops-team"
}
```


<!-- schema generated by tfplugindocs -->
## Schema

### Required

- `channel` (String) Name of the Slack channel that messages should be sent to. Note that HashiCorp Vault Radar will send a test message to verify the channel. Example: dev-ops-team
- `connection_id` (String) id of the integration slack connection to use for the subscription.
- `name` (String) Name of subscription. Name must be unique.

### Optional

- `project_id` (String) The ID of the HCP project where Vault Radar is located. If not specified, the project specified in the HCP Provider config block will be used, if configured.

### Read-Only

- `id` (String) The ID of this resource.




# hcp_vault_radar_source_github_cloud (Resource)

-> **Note:** This feature is currently in private beta.

This terraform resource manages a GitHub Cloud data source lifecycle in Vault Radar.

## Example Usage

```terraform
variable "github_cloud_token" {
  type      = string
  sensitive = true
}

resource "hcp_vault_radar_source_github_cloud" "example" {
  github_organization = "my-github-org"
  token               = var.github_cloud_token
  project_id          = "my-project-id"
}
```


<!-- schema generated by tfplugindocs -->
## Schema

### Required

- `github_organization` (String) GitHub organization Vault Radar will monitor. Example: type "octocat" for the org https://github.com/octocat
- `token` (String, Sensitive) GitHub personal access token.

### Optional

- `project_id` (String) The ID of the HCP project where Vault Radar is located. If not specified, the project specified in the HCP Provider config block will be used, if configured.

### Read-Only

- `id` (String) The ID of this resource.




# hcp_vault_radar_source_github_enterprise (Resource)

-> **Note:** This feature is currently in private beta.

This terraform resource manages a GitHub Enterprise Server data source lifecycle in Vault Radar.

## Example Usage

```terraform
variable "github_enterprise_token" {
  type      = string
  sensitive = true
}

resource "hcp_vault_radar_source_github_enterprise" "example" {
  domain_name         = "myserver.acme.com"
  github_organization = "my-github-org"
  token               = var.github_enterprise_token
  project_id          = "my-project-id"
}
```


<!-- schema generated by tfplugindocs -->
## Schema

### Required

- `domain_name` (String) Fully qualified domain name of the server. (Example: myserver.acme.com)
- `github_organization` (String) GitHub organization Vault Radar will monitor. Example: "octocat" for the org https://yourcodeserver.com/octocat
- `token` (String, Sensitive) GitHub personal access token.

### Optional

- `project_id` (String) The ID of the HCP project where Vault Radar is located. If not specified, the project specified in the HCP Provider config block will be used, if configured.

### Read-Only

- `id` (String) The ID of this resource.




# hcp_vault_secrets_app (Resource)

The Vault Secrets app resource manages an application.

## Example Usage

```terraform
resource "hcp_vault_secrets_app" "example" {
  app_name    = "example-app-name"
  description = "My new app!"
}
```

<!-- schema generated by tfplugindocs -->
## Schema

### Required

- `app_name` (String) The Vault Secrets App name.

### Optional

- `description` (String) The Vault Secrets app description
- `project_id` (String) The ID of the HCP project where the HCP Vault Secrets app is located.

### Read-Only

- `id` (String) Required ID field that is set to the app name.
- `organization_id` (String) The ID of the HCP organization where the project the HCP Vault Secrets app is located.
- `resource_name` (String) The app's resource name in the format secrets/project/<project ID>/app/<app Name>.




# hcp_vault_secrets_app_iam_binding (Resource)

Updates the Vault Secrets App IAM policy to bind a role to a new member. Existing bindings are preserved.

~> **Note:** `hcp_vault_secrets_app_iam_binding` cannot be used in conjunction with
`hcp_vault_secrets_app_iam_policy`.

## Example Usage

```terraform
resource "hcp_service_principal" "sp" {
  name = "example-sp"
}

resource "hcp_vault_secrets_app" "example" {
  app_name    = "example-app-name"
  description = "My new app!"
}

resource "hcp_vault_secrets_app_iam_binding" "example" {
  resource_name = hcp_vault_secrets_app.example.resource_name
  principal_id  = hcp_service_principal.sp.resource_id
  role          = "roles/secrets.app-secret-reader"
}
```

<!-- schema generated by tfplugindocs -->
## Schema

### Required

- `principal_id` (String) The principal to bind to the given role.
- `resource_name` (String) The app's resource name in the format secrets/project/<project ID>/app/<app Name>.
- `role` (String) The role name to bind to the given principal.




# hcp_vault_secrets_app_iam_policy (Resource)

!> **Be Careful!** You can accidentally lock yourself out of your vault secrets app using
this resource. Deleting a hcp_vault_secrets_app_iam_policy removes access from anyone
without organization or project level access to the app. This resource should generally only be used with apps fully managed by Terraform.
If you are trying to additively give permissions to the app, prefer using
`hcp_vault_secrets_app_iam_binding`. If you do use this resource, it is recommended to
import the policy before applying the change.

Sets the Vault Secrets App IAM policy and replaces any existing policy.

~> **Note:** `hcp_vault_secrets_app_iam_policy` can not be used in conjunction with
`hcp_vault_secrets_app_iam_binding`.

## Example Usage

```terraform
data "hcp_iam_policy" "example" {
  bindings = [
    {
      role = "roles/secrets.app-secret-reader"
      principals = [
        "example-user-id-1",
        "example-group-id-1",
        "example-sp-1"
      ]
    },
  ]
}


resource "hcp_vault_secrets_app" "example" {
  app_name    = "example-app-name"
  description = "My new app!"
}

resource "hcp_vault_secrets_app_iam_policy" "example" {
  resource_name = hcp_vault_secrets_app.example.resource_name
  policy_data   = data.hcp_iam_policy.example.policy_data
}
```

<!-- schema generated by tfplugindocs -->
## Schema

### Required

- `policy_data` (String) The policy to apply.
- `resource_name` (String) The app's resource name in the format secrets/project/<project ID>/app/<app Name>.

### Read-Only

- `etag` (String) The etag captures the existing state of the policy.

## Import

Import is supported using the following syntax:

```shell
# Vault Secrets App IAM Policy can be imported by specifying the resource name of the app
terraform import hcp_vault_secrets_app_iam_policy.example secrets/project/41d107a7-eea6-4b5e-8481-508ab29e2b07/app/example-app-name
```



# hcp_vault_secrets_dynamic_secret (Resource)

The Vault Secrets dynamic secret resource manages a dynamic secret configuration.

## Example Usage

```terraform
resource "hcp_vault_secrets_dynamic_secret" "example_aws" {
  app_name         = "my-app-1"
  secret_provider  = "aws"
  name             = "my_aws_1"
  integration_name = "my-integration-1"
  default_ttl      = "900s"
  aws_assume_role = {
    iam_role_arn = "arn:aws:iam::<account_id>:role/<role_name>"
  }
}

resource "hcp_vault_secrets_dynamic_secret" "example_gcp" {
  app_name         = "my-app-1"
  secret_provider  = "gcp"
  name             = "my_gcp_1"
  integration_name = "my-integration-1"
  default_ttl      = "900s"
  gcp_impersonate_service_account = {
    service_account_email = "<name>@<project>.iam.gserviceaccount.com"
  }
}
```

<!-- schema generated by tfplugindocs -->
## Schema

### Required

- `app_name` (String) Vault Secrets application name that owns the secret.
- `integration_name` (String) The Vault Secrets integration name with the capability to manage the secret's lifecycle.
- `name` (String) The Vault Secrets secret name.
- `secret_provider` (String) The third party platform the dynamic credentials give access to. One of `aws` or `gcp`.

### Optional

- `aws_assume_role` (Attributes) AWS configuration to generate dynamic credentials by assuming an IAM role. Required if `secret_provider` is `aws`. (see [below for nested schema](#nestedatt--aws_assume_role))
- `default_ttl` (String) TTL the generated credentials will be valid for.
- `gcp_impersonate_service_account` (Attributes) GCP configuration to generate dynamic credentials by impersonating a service account. Required if `secret_provider` is `gcp`. (see [below for nested schema](#nestedatt--gcp_impersonate_service_account))
- `project_id` (String) HCP project ID that owns the HCP Vault Secrets integration. Inferred from the provider configuration if omitted.

### Read-Only

- `organization_id` (String) HCP organization ID that owns the HCP Vault Secrets integration.

<a id="nestedatt--aws_assume_role"></a>
### Nested Schema for `aws_assume_role`

Required:

- `iam_role_arn` (String) AWS IAM role ARN to assume when generating credentials.


<a id="nestedatt--gcp_impersonate_service_account"></a>
### Nested Schema for `gcp_impersonate_service_account`

Required:

- `service_account_email` (String) GCP service account email to impersonate.




# hcp_vault_secrets_integration (Resource)

The Vault Secrets integration resource manages an integration.

## Example Usage

```terraform
// AWS
resource "hcp_vault_secrets_integration" "example_aws_federated_identity" {
  name          = "my-aws-1"
  capabilities  = ["DYNAMIC", "ROTATION"]
  provider_type = "aws"
  aws_federated_workload_identity = {
    audience = "<audience>>"
    role_arn = "<role-arn>"
  }
}

resource "hcp_vault_secrets_integration" "example_aws_access_keys" {
  name          = "my-aws-2"
  capabilities  = ["DYNAMIC", "ROTATION"]
  provider_type = "aws"
  aws_access_keys = {
    access_key_id     = "<access-key-id>"
    secret_access_key = "<secret-access-key>"
  }
}

// Confluent
resource "hcp_vault_secrets_integration" "example_confluent" {
  name          = "my-confluent-1"
  capabilities  = ["ROTATION"]
  provider_type = "confluent"
  confluent_static_credentials = {
    cloud_api_key_id = "<cloud-api-key-id>"
    cloud_api_secret = "<cloud-api-secret>"
  }
}

// GCP
resource "hcp_vault_secrets_integration" "example_gcp_json_service_account_key" {
  name          = "my-gcp-1"
  capabilities  = ["DYNAMIC", "ROTATION"]
  provider_type = "gcp"
  gcp_service_account_key = {
    credentials = file("${path.module}/my-service-account-key.json")
  }
}

resource "hcp_vault_secrets_integration" "example_gcp_base64_service_account_key" {
  name          = "my-gcp-2"
  capabilities  = ["DYNAMIC", "ROTATION"]
  provider_type = "gcp"
  gcp_service_account_key = {
    credentials = filebase64("${path.module}/my-service-account-key.json")
  }
}

resource "hcp_vault_secrets_integration" "example_gcp_federated_identity" {
  name          = "my-gcp-3"
  capabilities  = ["DYNAMIC", "ROTATION"]
  provider_type = "gcp"
  gcp_federated_workload_identity = {
    service_account_email = "<service-account-email>"
    audience              = "<audience>"
  }
}

// MongoDB-Atlas
resource "hcp_vault_secrets_integration" "example_mongodb_atlas" {
  name          = "my-mongodb-1"
  capabilities  = ["ROTATION"]
  provider_type = "mongodb-atlas"
  mongodb_atlas_static_credentials = {
    api_public_key  = "<api-public-key>"
    api_private_key = "<api-private-key>"
  }
}

// Twilio
resource "hcp_vault_secrets_integration" "example_twilio" {
  name          = "my-twilio-1"
  capabilities  = ["ROTATION"]
  provider_type = "twilio"
  twilio_static_credentials = {
    account_sid    = "<account-sid>"
    api_key_secret = "<api-key-secret>"
    api_key_sid    = "<api-key-sid>"
  }
}
```

<!-- schema generated by tfplugindocs -->
## Schema

### Required

- `capabilities` (Set of String) Capabilities enabled for the integration. See the Vault Secrets documentation for the list of supported capabilities per provider.
- `name` (String) The Vault Secrets integration name.
- `provider_type` (String) The provider or 3rd party platform the integration is for.

### Optional

- `aws_access_keys` (Attributes) AWS IAM key pair used to authenticate against the target AWS account. Cannot be used with `federated_workload_identity`. (see [below for nested schema](#nestedatt--aws_access_keys))
- `aws_federated_workload_identity` (Attributes) (Recommended) Federated identity configuration to authenticate against the target AWS account. Cannot be used with `access_keys`. (see [below for nested schema](#nestedatt--aws_federated_workload_identity))
- `azure_client_secret` (Attributes) Azure client secret used to authenticate against the target Azure application. Cannot be used with `federated_workload_identity`. (see [below for nested schema](#nestedatt--azure_client_secret))
- `azure_federated_workload_identity` (Attributes) (Recommended) Federated identity configuration to authenticate against the target Azure application. Cannot be used with `client_secret`. (see [below for nested schema](#nestedatt--azure_federated_workload_identity))
- `confluent_static_credentials` (Attributes) Confluent API key used to authenticate for cloud apis. (see [below for nested schema](#nestedatt--confluent_static_credentials))
- `gcp_federated_workload_identity` (Attributes) (Recommended) Federated identity configuration to authenticate against the target GCP project. Cannot be used with `service_account_key`. (see [below for nested schema](#nestedatt--gcp_federated_workload_identity))
- `gcp_service_account_key` (Attributes) GCP service account key used to authenticate against the target GCP project. Cannot be used with `federated_workload_identity`. (see [below for nested schema](#nestedatt--gcp_service_account_key))
- `gitlab_access` (Attributes) GitLab access token used to authenticate against the target GitLab account. (see [below for nested schema](#nestedatt--gitlab_access))
- `mongodb_atlas_static_credentials` (Attributes) MongoDB Atlas API key used to authenticate against the target project. (see [below for nested schema](#nestedatt--mongodb_atlas_static_credentials))
- `project_id` (String) HCP project ID that owns the HCP Vault Secrets integration. Inferred from the provider configuration if omitted.
- `twilio_static_credentials` (Attributes) Twilio API key parts used to authenticate against the target Twilio account. (see [below for nested schema](#nestedatt--twilio_static_credentials))

### Read-Only

- `organization_id` (String) HCP organization ID that owns the HCP Vault Secrets integration.
- `resource_id` (String) Resource ID used to uniquely identify the integration instance on the HCP platform.
- `resource_name` (String) Resource name used to uniquely identify the integration instance on the HCP platform.

<a id="nestedatt--aws_access_keys"></a>
### Nested Schema for `aws_access_keys`

Required:

- `access_key_id` (String) Key ID used with the secret key to authenticate against the target AWS account.
- `secret_access_key` (String, Sensitive) Secret key used with the key ID to authenticate against the target AWS account.


<a id="nestedatt--aws_federated_workload_identity"></a>
### Nested Schema for `aws_federated_workload_identity`

Required:

- `audience` (String) Audience configured on the AWS IAM identity provider to federate access with HCP.
- `role_arn` (String) AWS IAM role ARN the integration will assume to carry operations for the appropriate capabilities.


<a id="nestedatt--azure_client_secret"></a>
### Nested Schema for `azure_client_secret`

Required:

- `client_id` (String) Azure client ID corresponding to the Azure application.
- `client_secret` (String) Secret value corresponding to the Azure client secret.
- `tenant_id` (String) Azure tenant ID corresponding to the Azure application.


<a id="nestedatt--azure_federated_workload_identity"></a>
### Nested Schema for `azure_federated_workload_identity`

Required:

- `audience` (String) Audience configured on the Azure federated identity credentials to federate access with HCP.
- `client_id` (String) Azure client ID corresponding to the Azure application.
- `tenant_id` (String) Azure tenant ID corresponding to the Azure application.


<a id="nestedatt--confluent_static_credentials"></a>
### Nested Schema for `confluent_static_credentials`

Required:

- `cloud_api_key_id` (String) Public key used alongside the private key to authenticate for cloud apis.
- `cloud_api_secret` (String, Sensitive) Private key used alongside the public key to authenticate for cloud apis.


<a id="nestedatt--gcp_federated_workload_identity"></a>
### Nested Schema for `gcp_federated_workload_identity`

Required:

- `audience` (String) Audience configured on the GCP identity provider to federate access with HCP.
- `service_account_email` (String) GCP service account email that HVS will impersonate to carry operations for the appropriate capabilities.


<a id="nestedatt--gcp_service_account_key"></a>
### Nested Schema for `gcp_service_account_key`

Required:

- `credentials` (String) JSON or base64 encoded service account key received from GCP.

Read-Only:

- `client_email` (String) Service account email corresponding to the service account key.
- `project_id` (String) GCP project ID corresponding to the service account key.


<a id="nestedatt--gitlab_access"></a>
### Nested Schema for `gitlab_access`

Required:

- `token` (String, Sensitive) Access token used to authenticate against the target GitLab account.


<a id="nestedatt--mongodb_atlas_static_credentials"></a>
### Nested Schema for `mongodb_atlas_static_credentials`

Required:

- `api_private_key` (String, Sensitive) Private key used alongside the public key to authenticate against the target project.
- `api_public_key` (String) Public key used alongside the private key to authenticate against the target project.


<a id="nestedatt--twilio_static_credentials"></a>
### Nested Schema for `twilio_static_credentials`

Required:

- `account_sid` (String) Account SID for the target Twilio account.
- `api_key_secret` (String, Sensitive) Api key secret used with the api key SID to authenticate against the target Twilio account.
- `api_key_sid` (String) Api key SID to authenticate against the target Twilio account.

## Import

Import is supported using the following syntax:

```shell
# Vault Secrets Integration can be imported by specifying the name of the integration
# Note that since sensitive information are never returned on the Vault Secrets API,
# the next plan or apply will show a diff for sensitive fields.
terraform import hcp_vault_secrets_integration.example my-integration-name
```




# hcp_vault_secrets_integration_aws (Resource)

The Vault Secrets AWS integration resource manages an AWS integration.

~> **Note:** This resource is deprecated, please use `hcp_vault_secrets_integration` instead.

## Example Usage

```terraform
resource "hcp_vault_secrets_integration_aws" "example_with_access_keys" {
  name         = "my-aws-1"
  capabilities = ["DYNAMIC", "ROTATION"]
  access_keys = {
    access_key_id     = "AKIA..."
    secret_access_key = "rgUK..."
  }
}

resource "hcp_vault_secrets_integration_aws" "example_with_identity_federation" {
  name         = "my-aws-1"
  capabilities = ["DYNAMIC", "ROTATION"]
  federated_workload_identity = {
    role_arn = "arn:aws:iam::<your-account-id>:role/<your-role>>"
    audience = "<your-audience>"
  }
}
```

<!-- schema generated by tfplugindocs -->
## Schema

### Required

- `capabilities` (Set of String) Capabilities enabled for the integration. See the Vault Secrets documentation for the list of supported capabilities per provider.
- `name` (String) The Vault Secrets integration name.

### Optional

- `access_keys` (Attributes) AWS IAM key pair used to authenticate against the target AWS account. Cannot be used with `federated_workload_identity`. (see [below for nested schema](#nestedatt--access_keys))
- `federated_workload_identity` (Attributes) (Recommended) Federated identity configuration to authenticate against the target AWS account. Cannot be used with `access_keys`. (see [below for nested schema](#nestedatt--federated_workload_identity))
- `project_id` (String) HCP project ID that owns the HCP Vault Secrets integration. Inferred from the provider configuration if omitted.

### Read-Only

- `organization_id` (String) HCP organization ID that owns the HCP Vault Secrets integration.
- `resource_id` (String) Resource ID used to uniquely identify the integration instance on the HCP platform.
- `resource_name` (String) Resource name used to uniquely identify the integration instance on the HCP platform.

<a id="nestedatt--access_keys"></a>
### Nested Schema for `access_keys`

Required:

- `access_key_id` (String) Key ID used with the secret key to authenticate against the target AWS account.
- `secret_access_key` (String, Sensitive) Secret key used with the key ID to authenticate against the target AWS account.


<a id="nestedatt--federated_workload_identity"></a>
### Nested Schema for `federated_workload_identity`

Required:

- `audience` (String) Audience configured on the AWS IAM identity provider to federate access with HCP.
- `role_arn` (String) AWS IAM role ARN the integration will assume to carry operations for the appropriate capabilities.

## Import

Import is supported using the following syntax:

```shell
# Vault Secrets AWS Integration can be imported by specifying the name of the integration
# Note that since the AWS secret access key is never returned on the Vault Secrets API,
# the next plan or apply will show a diff for that field if using the access keys authentication method.
terraform import hcp_vault_secrets_integration_aws.example my-aws-1
```




# hcp_vault_secrets_integration_azure (Resource)

The Vault Secrets Azure integration resource manages an Azure integration.

~> **Note:** This resource is deprecated, please use `hcp_vault_secrets_integration` instead.

## Example Usage

```terraform
resource "hcp_vault_secrets_integration_azure" "example" {
  name         = "my-azure-1"
  capabilities = ["ROTATION"]
  client_secret = {
    "tenant_id"     = "7eb3...",
    "client_id"     = "9de0...",
    "client_secret" = "WZk8..."
  }
}
```

<!-- schema generated by tfplugindocs -->
## Schema

### Required

- `capabilities` (Set of String) Capabilities enabled for the integration. See the Vault Secrets documentation for the list of supported capabilities per provider.
- `name` (String) The Vault Secrets integration name.

### Optional

- `client_secret` (Attributes) Azure client secret used to authenticate against the target Azure application. Cannot be used with `federated_workload_identity`. (see [below for nested schema](#nestedatt--client_secret))
- `federated_workload_identity` (Attributes) (Recommended) Federated identity configuration to authenticate against the target Azure application. Cannot be used with `client_secret`. (see [below for nested schema](#nestedatt--federated_workload_identity))
- `project_id` (String) HCP project ID that owns the HCP Vault Secrets integration. Inferred from the provider configuration if omitted.

### Read-Only

- `organization_id` (String) HCP organization ID that owns the HCP Vault Secrets integration.
- `resource_id` (String) Resource ID used to uniquely identify the integration instance on the HCP platform.
- `resource_name` (String) Resource name used to uniquely identify the integration instance on the HCP platform.

<a id="nestedatt--client_secret"></a>
### Nested Schema for `client_secret`

Required:

- `client_id` (String) Azure client ID corresponding to the Azure application.
- `client_secret` (String) Secret value corresponding to the Azure client secret.
- `tenant_id` (String) Azure tenant ID corresponding to the Azure application.


<a id="nestedatt--federated_workload_identity"></a>
### Nested Schema for `federated_workload_identity`

Required:

- `audience` (String) Audience configured on the Azure federated identity credentials to federate access with HCP.
- `client_id` (String) Azure client ID corresponding to the Azure application.
- `tenant_id` (String) Azure tenant ID corresponding to the Azure application.

## Import

Import is supported using the following syntax:

```shell
# Vault Secrets Azure Integration can be imported by specifying the name of the integration
# Note that since the client secret is never returned on the Vault Secrets API,
# the next plan or apply will show a diff for that field.
terraform import hcp_vault_secrets_integration_azure.example my-azure-1
```




# hcp_vault_secrets_integration_confluent (Resource)

The Vault Secrets Confluent integration resource manages an Confluent integration.

~> **Note:** This resource is deprecated, please use `hcp_vault_secrets_integration` instead.

## Example Usage

```terraform
resource "hcp_vault_secrets_integration_confluent" "example" {
  name         = "my-confluent-1"
  capabilities = ["ROTATION"]
  static_credential_details = {
    cloud_api_key_id = "TKa..."
    cloud_api_secret = "6aG..."
  }
}
```

<!-- schema generated by tfplugindocs -->
## Schema

### Required

- `capabilities` (Set of String) Capabilities enabled for the integration. See the Vault Secrets documentation for the list of supported capabilities per provider.
- `name` (String) The Vault Secrets integration name.

### Optional

- `project_id` (String) HCP project ID that owns the HCP Vault Secrets integration. Inferred from the provider configuration if omitted.
- `static_credential_details` (Attributes) Confluent API key used to authenticate for cloud apis. (see [below for nested schema](#nestedatt--static_credential_details))

### Read-Only

- `organization_id` (String) HCP organization ID that owns the HCP Vault Secrets integration.
- `resource_id` (String) Resource ID used to uniquely identify the integration instance on the HCP platform.
- `resource_name` (String) Resource name used to uniquely identify the integration instance on the HCP platform.

<a id="nestedatt--static_credential_details"></a>
### Nested Schema for `static_credential_details`

Required:

- `cloud_api_key_id` (String) Public key used alongside the private key to authenticate for cloud apis.
- `cloud_api_secret` (String, Sensitive) Private key used alongside the public key to authenticate for cloud apis.

## Import

Import is supported using the following syntax:

```shell
# Vault Secrets Confluent Integration can be imported by specifying the name of the integration
# Note that since the Api Key secret is never returned on the Vault Secrets API,
# the next plan or apply will show a diff for that field.
terraform import hcp_vault_secrets_integration_confluent.example my-confluent-1
```




# hcp_vault_secrets_integration_gcp (Resource)

The Vault Secrets GCP integration resource manages an GCP integration.

~> **Note:** This resource is deprecated, please use `hcp_vault_secrets_integration` instead.

## Example Usage

```terraform
resource "hcp_vault_secrets_integration_gcp" "example_with_federated_identity" {
  name         = "my-gcp-1"
  capabilities = ["DYNAMIC", "ROTATION"]
  federated_workload_identity = {
    service_account_email = "my-service-account@my-project-123456.iam.gserviceaccount.com"
    audience              = "https://iam.googleapis.com/projects/123456/locations/global/workloadIdentityPools/my-identity-pool/providers/my-provider"
  }
}

resource "hcp_vault_secrets_integration_gcp" "example_with_base64_service_account_key" {
  name         = "my-gcp-2"
  capabilities = ["DYNAMIC", "ROTATION"]
  service_account_key = {
    credentials = filebase64("${path.module}/service_account_key.json")
  }
}


resource "hcp_vault_secrets_integration_gcp" "example_json_service_account_key" {
  name         = "my-gcp-3"
  capabilities = ["DYNAMIC", "ROTATION"]
  service_account_key = {
    credentials = file("${path.module}/service_account_key.json")
  }
}
```

<!-- schema generated by tfplugindocs -->
## Schema

### Required

- `capabilities` (Set of String) Capabilities enabled for the integration. See the Vault Secrets documentation for the list of supported capabilities per provider.
- `name` (String) The Vault Secrets integration name.

### Optional

- `federated_workload_identity` (Attributes) (Recommended) Federated identity configuration to authenticate against the target GCP project. Cannot be used with `service_account_key`. (see [below for nested schema](#nestedatt--federated_workload_identity))
- `project_id` (String) HCP project ID that owns the HCP Vault Secrets integration. Inferred from the provider configuration if omitted.
- `service_account_key` (Attributes) GCP service account key used to authenticate against the target GCP project. Cannot be used with `federated_workload_identity`. (see [below for nested schema](#nestedatt--service_account_key))

### Read-Only

- `organization_id` (String) HCP organization ID that owns the HCP Vault Secrets integration.
- `resource_id` (String) Resource ID used to uniquely identify the integration instance on the HCP platform.
- `resource_name` (String) Resource name used to uniquely identify the integration instance on the HCP platform.

<a id="nestedatt--federated_workload_identity"></a>
### Nested Schema for `federated_workload_identity`

Required:

- `audience` (String) Audience configured on the GCP identity provider to federate access with HCP.
- `service_account_email` (String) GCP service account email that HVS will impersonate to carry operations for the appropriate capabilities.


<a id="nestedatt--service_account_key"></a>
### Nested Schema for `service_account_key`

Required:

- `credentials` (String) JSON or base64 encoded service account key received from GCP.

Read-Only:

- `client_email` (String) Service account email corresponding to the service account key.
- `project_id` (String) GCP project ID corresponding to the service account key.

## Import

Import is supported using the following syntax:

```shell
# Vault Secrets GCP Integration can be imported by specifying the name of the integration
# Note that since the service account credentials are never returned on the Vault Secrets API,
# the next plan or apply will show a diff for that field if using the service account key authentication method.
terraform import hcp_vault_secrets_integration_gcp.example my-gcp-1
```




# hcp_vault_secrets_integration_mongodbatlas (Resource)

The Vault Secrets MongoDB Atlas integration resource manages an MongoDB Atlas integration.

~> **Note:** This resource is deprecated, please use `hcp_vault_secrets_integration` instead.

## Example Usage

```terraform
resource "hcp_vault_secrets_integration_mongodbatlas" "example" {
  name         = "my-mongodbatlas-1"
  capabilities = ["ROTATION"]
  static_credential_details = {
    api_private_key = "12345678-1234-1234-1234-12345678"
    api_public_key  = "abcdefgh"
  }
}
```

<!-- schema generated by tfplugindocs -->
## Schema

### Required

- `capabilities` (Set of String) Capabilities enabled for the integration. See the Vault Secrets documentation for the list of supported capabilities per provider.
- `name` (String) The Vault Secrets integration name.

### Optional

- `project_id` (String) HCP project ID that owns the HCP Vault Secrets integration. Inferred from the provider configuration if omitted.
- `static_credential_details` (Attributes) MongoDB Atlas API key used to authenticate against the target project. (see [below for nested schema](#nestedatt--static_credential_details))

### Read-Only

- `organization_id` (String) HCP organization ID that owns the HCP Vault Secrets integration.
- `resource_id` (String) Resource ID used to uniquely identify the integration instance on the HCP platform.
- `resource_name` (String) Resource name used to uniquely identify the integration instance on the HCP platform.

<a id="nestedatt--static_credential_details"></a>
### Nested Schema for `static_credential_details`

Required:

- `api_private_key` (String, Sensitive) Private key used alongside the public key to authenticate against the target project.
- `api_public_key` (String) Public key used alongside the private key to authenticate against the target project.

## Import

Import is supported using the following syntax:

```shell
# Vault Secrets Mongo DB Atlas Integration can be imported by specifying the name of the integration
# Note that since the API private key is never returned on the Vault Secrets API,
# the next plan or apply will show a diff for that field.
terraform import hcp_vault_secrets_integration_mongodbatlas.example my-mongodbatlas-1
```




# hcp_vault_secrets_integration_twilio (Resource)

The Vault Secrets Twilio integration resource manages a Twilio integration.

~> **Note:** This resource is deprecated, please use `hcp_vault_secrets_integration` instead.

## Example Usage

```terraform
resource "hcp_vault_secrets_integration_twilio" "example" {
  name         = "my-twilio-1"
  capabilities = ["ROTATION"]
  static_credential_details = {
    account_sid    = "AC7..."
    api_key_sid    = "TKa..."
    api_key_secret = "6aG..."
  }
}
```

<!-- schema generated by tfplugindocs -->
## Schema

### Required

- `capabilities` (Set of String) Capabilities enabled for the integration. See the Vault Secrets documentation for the list of supported capabilities per provider.
- `name` (String) The Vault Secrets integration name.

### Optional

- `project_id` (String) HCP project ID that owns the HCP Vault Secrets integration. Inferred from the provider configuration if omitted.
- `static_credential_details` (Attributes) Twilio API key parts used to authenticate against the target Twilio account. (see [below for nested schema](#nestedatt--static_credential_details))

### Read-Only

- `organization_id` (String) HCP organization ID that owns the HCP Vault Secrets integration.
- `resource_id` (String) Resource ID used to uniquely identify the integration instance on the HCP platform.
- `resource_name` (String) Resource name used to uniquely identify the integration instance on the HCP platform.

<a id="nestedatt--static_credential_details"></a>
### Nested Schema for `static_credential_details`

Required:

- `account_sid` (String) Account SID for the target Twilio account.
- `api_key_secret` (String, Sensitive) Api key secret used with the api key SID to authenticate against the target Twilio account.
- `api_key_sid` (String) Api key SID to authenticate against the target Twilio account.

## Import

Import is supported using the following syntax:

```shell
# Vault Secrets Twilio Integration can be imported by specifying the name of the integration
# Note that since the Api Key secret is never returned on the Vault Secrets API,
# the next plan or apply will show a diff for that field.
terraform import hcp_vault_secrets_integration_twilio.example my-twilio-1
```




# hcp_vault_secrets_rotating_secret (Resource)

The Vault Secrets rotating secret resource manages a rotating secret configuration.

## Example Usage

```terraform
resource "hcp_vault_secrets_rotating_secret" "example_aws" {
  app_name             = "my-app-1"
  secret_provider      = "aws"
  name                 = "my_aws_1"
  integration_name     = "my-aws-1"
  rotation_policy_name = "built-in:60-days-2-active"
  aws_access_keys = {
    iam_username = "my-iam-username"
  }
}

resource "hcp_vault_secrets_rotating_secret" "example_gcp" {
  app_name             = "my-app-1"
  secret_provider      = "gcp"
  name                 = "my_gcp_1"
  integration_name     = "my-gcp-1"
  rotation_policy_name = "built-in:60-days-2-active"
  gcp_service_account_key = {
    service_account_email = "<name>>@<project>.iam.gserviceaccount.com"
  }
}

resource "hcp_vault_secrets_rotating_secret" "example_mongodb_atlas" {
  app_name             = "my-app-1"
  secret_provider      = "mongodb_atlas"
  name                 = "my_mongodb_atlas_1"
  integration_name     = "my-mongodbatlas-1"
  rotation_policy_name = "built-in:60-days-2-active"
  mongodb_atlas_user = {
    project_id    = "<uuid>>"
    database_name = "my-cluster-0"
    roles         = ["readWrite", "read"]
  }
}

resource "hcp_vault_secrets_rotating_secret" "example_twilio" {
  app_name             = "my-app-1"
  secret_provider      = "twilio"
  name                 = "my_twilio_1"
  integration_name     = "my-twilio-1"
  rotation_policy_name = "built-in:60-days-2-active"
  twilio_api_key       = {}
}

resource "hcp_vault_secrets_rotating_secret" "example_confluent" {
  app_name             = "my-app-1"
  secret_provider      = "confluent"
  name                 = "my_confluent_1"
  integration_name     = "my-confluent-1"
  rotation_policy_name = "built-in:60-days-2-active"
  confluent_service_account = {
    service_account_id = "<service-account-id>"
  }
}

resource "hcp_vault_secrets_rotating_secret" "example_azure" {
  app_name             = "my-app-1"
  secret_provider      = "azure"
  name                 = "my_azure_1_secret"
  integration_name     = "my-azure-1"
  rotation_policy_name = "built-in:60-days-2-active"
  azure_application_password = {
    app_object_id = "<app_object_id>"
    app_client_id = "<app_client_id>"
  }
}
```

<!-- schema generated by tfplugindocs -->
## Schema

### Required

- `app_name` (String) Vault Secrets application name that owns the secret.
- `integration_name` (String) The Vault Secrets integration name with the capability to manage the secret's lifecycle.
- `name` (String) The Vault Secrets secret name.
- `rotation_policy_name` (String) Name of the rotation policy that governs the rotation of the secret.
- `secret_provider` (String) The third party platform the dynamic credentials give access to. One of `aws` or `gcp`.

### Optional

- `aws_access_keys` (Attributes) AWS configuration to manage the access key rotation for the given IAM user. Required if `secret_provider` is `aws`. (see [below for nested schema](#nestedatt--aws_access_keys))
- `azure_application_password` (Attributes) Azure configuration to manage the application password rotation for the given application. Required if `secret_provider` is `Azure`. (see [below for nested schema](#nestedatt--azure_application_password))
- `confluent_service_account` (Attributes) Confluent configuration to manage the cloud api key rotation for the given service account. Required if `secret_provider` is `confluent`. (see [below for nested schema](#nestedatt--confluent_service_account))
- `gcp_service_account_key` (Attributes) GCP configuration to manage the service account key rotation for the given service account. Required if `secret_provider` is `gcp`. (see [below for nested schema](#nestedatt--gcp_service_account_key))
- `mongodb_atlas_user` (Attributes) MongoDB Atlas configuration to manage the user password rotation on the given database. Required if `secret_provider` is `mongodb_atlas`. (see [below for nested schema](#nestedatt--mongodb_atlas_user))
- `project_id` (String) HCP project ID that owns the HCP Vault Secrets integration. Inferred from the provider configuration if omitted.
- `twilio_api_key` (Attributes) Twilio configuration to manage the api key rotation on the given account. Required if `secret_provider` is `twilio`. (see [below for nested schema](#nestedatt--twilio_api_key))

### Read-Only

- `organization_id` (String) HCP organization ID that owns the HCP Vault Secrets integration.

<a id="nestedatt--aws_access_keys"></a>
### Nested Schema for `aws_access_keys`

Required:

- `iam_username` (String) AWS IAM username to rotate the access keys for.


<a id="nestedatt--azure_application_password"></a>
### Nested Schema for `azure_application_password`

Required:

- `app_client_id` (String) Application client ID to rotate the application password for.
- `app_object_id` (String) Application object ID to rotate the application password for.


<a id="nestedatt--confluent_service_account"></a>
### Nested Schema for `confluent_service_account`

Required:

- `service_account_id` (String) Confluent service account to rotate the cloud api key for.


<a id="nestedatt--gcp_service_account_key"></a>
### Nested Schema for `gcp_service_account_key`

Required:

- `service_account_email` (String) GCP service account email to impersonate.


<a id="nestedatt--mongodb_atlas_user"></a>
### Nested Schema for `mongodb_atlas_user`

Required:

- `database_name` (String) MongoDB Atlas database or cluster name to rotate the username and password for.
- `project_id` (String) MongoDB Atlas project ID to rotate the username and password for.
- `roles` (List of String) MongoDB Atlas roles to assign to the rotating user.


<a id="nestedatt--twilio_api_key"></a>
### Nested Schema for `twilio_api_key`




# hcp_vault_secrets_secret (Resource)

-> **Note:** Please treat your state file as sensitive when using this resource.

The Vault Secrets secret resource manages a secret within a given application.

## Example Usage

```terraform
resource "hcp_vault_secrets_secret" "example" {
  app_name     = "example-app-name"
  secret_name  = "example_secret"
  secret_value = "hashi123"
}
```

<!-- schema generated by tfplugindocs -->
## Schema

### Required

- `app_name` (String) The name of the application the secret can be found in
- `secret_name` (String) The name of the secret
- `secret_value` (String, Sensitive) The value of the secret

### Optional

- `project_id` (String) The ID of the HCP project where the HCP Vault Secrets secret is located.

### Read-Only

- `id` (String) The id of the resource
- `organization_id` (String) The ID of the HCP organization where the project the HCP Vault Secrets secret is located.




# Create a new Vault cluster and an admin token

Once you have an HVN, HCP Vault enables you to quickly deploy a Vault Enterprise cluster in AWS across a variety of environments while offloading the operations burden to the SRE experts at HashiCorp.
The cluster's admin token grants its bearer administrator access to the Vault cluster. This admin token is valid for six hours. On subsequent reads after creation,
the resource will check if the admin token is close to expiration or expired and automatically refresh as needed.

```terraform
resource "hcp_vault_cluster" "example_vault_cluster" {
  hvn_id     = hcp_hvn.example_hvn.hvn_id
  cluster_id = "hcp-tf-example-vault-cluster"
}

resource "hcp_vault_cluster_admin_token" "example_vault_admin_token" {
  cluster_id = hcp_vault_cluster.example_vault_cluster.cluster_id
}
```




# Configure Vault performance replication

Admins and Contributors can use the provider to create Plus tier clusters with Vault [performance replication](https://developer.hashicorp.com/vault/tutorials/cloud-ops/vault-replication-terraform) enabled via the `primary_link` parameter. In addition to both clusters being in the Plus tier, both must be of the same size (S, M, L).

Although the clusters may reside in the same HVN, it is more likely that you will want to station your performance replication secondary in a different region, and therefore HVN, than your primary. When establishing performance replication links between clusters in different HVNs, an HVN peering connection is required. This can be defined explicitly using an [`hcp_hvn_peering_connection`](../resources/hvn_peering_connection.md), or HCP will create the connection automatically (peering connections can be imported after creation using [terraform import](https://www.terraform.io/cli/import)). Note HVN peering [CIDR block requirements](https://cloud.hashicorp.com/docs/hcp/network/routes#cidr-block-requirements).

-> **Note:** Remember, when scaling performance replicated clusters, be sure to keep the size of all clusters in the group in sync.

### Performance replication example

Clusters configured with performance replication enabled:
```terraform
resource "hcp_hvn" "primary_network" {
  hvn_id         = "hvn1"
  cloud_provider = "aws"
  region         = "us-west-2"
  cidr_block     = "172.25.16.0/20"
}

resource "hcp_vault_cluster" "primary" {
  cluster_id = "vault-cluster"
  hvn_id     = hcp_hvn.primary_network.hvn_id
  tier       = "plus_medium"
}

resource "hcp_hvn" "secondary_network" {
  hvn_id         = "hvn2"
  cloud_provider = "aws"
  region         = "eu-central-1"
  cidr_block     = "172.26.16.0/20"
}

resource "hcp_vault_cluster" "secondary" {
  cluster_id   = "vault-cluster"
  hvn_id       = hcp_hvn.secondary_network.hvn_id
  tier         = hcp_vault_cluster.primary.tier
  primary_link = hcp_vault_cluster.primary.self_link
  paths_filter = ["path/a", "path/b"]
}
```

## Tutorials

Refer to the [Deploy HCP Vault Performance Replication with Terraform](https://developer.hashicorp.com/vault/tutorials/cloud-ops/vault-replication-terraform) tutorial for additional usage examples.




# Scale a cluster

Admins are able to use the provider to change a cluster’s size or tier. There are a few limitations on cluster scaling:

- When scaling performance replicated Plus-tier clusters, be sure to keep the size of all clusters in the group in sync
- Scaling down to the Development tier from any production-grade tier is not allowed
- If you are using too much storage and want to scale down to a smaller size or tier, you will be unable to do so until you delete enough resources

### Scaling example

Initial Cluster:
```terraform
resource "hcp_hvn" "example" {
  hvn_id         = "hvn"
  cloud_provider = "aws"
  region         = "us-west-2"
  cidr_block     = "172.25.16.0/20"
}

resource "hcp_vault_cluster" "example" {
  cluster_id = "vault-cluster"
  hvn_id     = hcp_hvn.example.hvn_id
  # default tier is “dev”
}
```

Scaling to Standard:
```terraform
resource "hcp_hvn" "example" {
  hvn_id         = "hvn"
  cloud_provider = "aws"
  region         = "us-west-2"
  cidr_block     = "172.25.16.0/20"
}

resource "hcp_vault_cluster" "example" {
  cluster_id = "vault-cluster"
  hvn_id     = hcp_hvn.example.hvn_id
  tier       = "standard_medium"
}
```





The HCP Provider offers two ways of accessing secrets as a data source. The first is through fetching an app’s worth of secrets and the second is through fetching a singular secret by name.

Below is an example of fetching an app’s worth of secrets and accessing this throughout your Terraform configuration.

```terraform
data "hcp_vault_secrets_app" "my_app" {
  app_name = "example-vault-secrets-app"
}

resource "example_resource" "example" {
  example_attr = data.hcp_vault_secrets_app.my_app.secrets["my_secret_key"]
}
```

We also allow you to fetch a singular secret from Vault Secrets.

```terraform
data "hcp_vault_secrets_secret" "secret_data" {
  app_name    = "example-vault-secrets-app"
  secret_name = "my_secret"
}

resource "example_resource" "example" {
  example_attr = data.hcp_vault_secrets_secret.secret_data.secret_value
}
```

If the secret you are trying to fetch is known to be of type 'rotating', then using the following data source will give a more granual access to the secret's nested data:

```terraform
data "hcp_vault_secrets_rotating_secret" "secret_data" {
  app_name    = "example-vault-secrets-app"
  secret_name = "my_secret"
}

resource "example_resource" "example" {
  example_attr1 = data.hcp_vault_secrets_rotating_secret.secret_data.secret_values["username"]
  example_attr2 = data.hcp_vault_secrets_rotating_secret.secret_data.secret_values["password"]
}
```




The HCP Provider allows you to manage your Vault Secrets apps and secrets.

The Vault Secrets app resource allows you to manage your application through the following configuration:

```terraform
resource "hcp_vault_secrets_app" "example" {
  app_name    = "example-app-name"
  description = "My new app!"
}
```

We can also use this to create secrets based off our new application.

```terraform
resource "hcp_vault_secrets_app" "example" {
  app_name    = "example-app-name"
  description = "My new app!"
}
resource "hcp_vault_secrets_secret" "secret-example" {
  app_name     = hcp.hcp_vault_secrets_app.example.app_name
  secret_name  = "a-new-secret"
  secret_value = "a test secret"
}
```

-> **Note:** The secret value is considered sensitive and will be masked with any output. However, the secret value will be written to your state file and we recommend treating the [state file as sensitive](https://developer.hashicorp.com/terraform/language/state/sensitive-data)




# hcp_waypoint_action `Resource`

-> **Note:** HCP Waypoint is currently in public beta.

The Waypoint Action resource manages the lifecycle of an Action.

<!-- schema generated by tfplugindocs -->
## Schema

### Required

- `name` (String) The name of the Action.
- `request` (Attributes) The kind of HTTP request this should trigger. (see [below for nested schema](#nestedatt--request))

### Optional

- `description` (String) A description of the Action.
- `project_id` (String) The ID of the HCP project where the Action is located.

### Read-Only

- `id` (String) The ID of the Action.
- `organization_id` (String) The ID of the HCP organization where the Action is located.

<a id="nestedatt--request"></a>
### Nested Schema for `request`

Optional:

- `custom` (Attributes) Custom mode allows users to define the HTTP method, the request body, etc. (see [below for nested schema](#nestedatt--request--custom))

<a id="nestedatt--request--custom"></a>
### Nested Schema for `request.custom`

Required:

- `method` (String) The HTTP method to use for the request. Must be one of: 'GET', 'POST', 'PUT', 'DELETE', or 'PATCH'.

Optional:

- `body` (String) The body to be submitted with the request.
- `headers` (Map of String) Key value headers to send with the request.
- `url` (String) The full URL this request should make when invoked.



# hcp_waypoint_add_on `Resource`

-> **Note:** HCP Waypoint is currently in public beta.

Waypoint Add-on resource

<!-- schema generated by tfplugindocs -->
## Schema

### Required

- `application_id` (String) The ID of the Application that this Add-on is created for.
- `definition_id` (String) The ID of the Add-on Definition that this Add-on is created from.
- `name` (String) The name of the Add-on.

### Optional

- `add_on_input_variables` (Attributes Set) Input variables set for the add-on. (see [below for nested schema](#nestedatt--add_on_input_variables))
- `project_id` (String) The ID of the HCP project where the Waypoint AddOn is located.

### Read-Only

- `add_on_definition_input_variables` (Attributes Set) Input variables set for the add-on definition. (see [below for nested schema](#nestedatt--add_on_definition_input_variables))
- `created_by` (String) The user who created the Add-on.
- `description` (String) A longer description of the Add-on.
- `id` (String) The ID of the Add-on.
- `install_count` (Number) The number of installed Add-ons for the same Application that share the same Add-on Definition.
- `labels` (List of String) List of labels attached to this Add-on.
- `organization_id` (String) The ID of the HCP organization where the Waypoint AddOn is located.
- `output_values` (Attributes List) The output values, stored by HCP Waypoint, of the Terraform run for the Add-on, sensitive values have type and value omitted. (see [below for nested schema](#nestedatt--output_values))
- `readme_markdown` (String) The markdown for the Add-on README.
- `status` (Number) The status of the Terraform run for the Add-on.
- `summary` (String) A short summary of the Add-on.
- `terraform_no_code_module_source` (String) The Terraform No Code Module source for the Add-on.

<a id="nestedatt--add_on_input_variables"></a>
### Nested Schema for `add_on_input_variables`

Required:

- `name` (String) Variable name
- `value` (String) Variable value
- `variable_type` (String) Variable type


<a id="nestedatt--add_on_definition_input_variables"></a>
### Nested Schema for `add_on_definition_input_variables`

Required:

- `name` (String) Variable name
- `value` (String) Variable value

Optional:

- `variable_type` (String) Variable type


<a id="nestedatt--output_values"></a>
### Nested Schema for `output_values`

Read-Only:

- `name` (String) The name of the output value.
- `sensitive` (Boolean) Whether the output value is sensitive.
- `type` (String) The type of the output value.
- `value` (String) The value of the output value.



# hcp_waypoint_add_on_definition `Resource`

-> **Note:** HCP Waypoint is currently in public beta.

Waypoint Add-on Definition resource

## Example Usage

```terraform
resource "hcp_waypoint_add_on_definition" "add_on_definition" {
  name                            = "postgres"
  summary                         = "An add-on that provisions a PostgreSQL database."
  description                     = <<EOF
This add-on provisions a PostgreSQL database in AWS. The database is provisioned
with a default schema and user.
EOF
  terraform_project_id            = "prj-123456"
  labels                          = ["postgres", "aws", "db"]
  terraform_no_code_module_source = "private/fake-org/postgres-aws/aws"
  terraform_no_code_module_id     = "nocode-abcdef"
  variable_options = [
    {
      name          = "size"
      user_editable = true
      options       = ["small", "medium", "large"]
    }
  ]
}
```

<!-- schema generated by tfplugindocs -->
## Schema

### Required

- `description` (String) A longer description of the Add-on Definition.
- `name` (String) The name of the Add-on Definition.
- `summary` (String) A short summary of the Add-on Definition.
- `terraform_no_code_module_id` (String) The ID of the Terraform no-code module to use for running Terraform operations. This is in the format of 'nocode-<ID>'.
- `terraform_no_code_module_source` (String) Terraform Cloud no-code Module Source, expected to be in one of the following formats: "app.terraform.io/hcp_waypoint_example/ecs-advanced-microservice/aws" or "private/hcp_waypoint_example/ecs-advanced-microservice/aws".
- `terraform_project_id` (String) The ID of the Terraform Cloud Project to create workspaces in. The ID is found on the Terraform Cloud Project settings page.

### Optional

- `labels` (List of String) List of labels attached to this Add-on Definition.
- `project_id` (String) The ID of the HCP project where the Waypoint Add-on Definition is located.
- `readme_markdown_template` (String) The markdown template for the Add-on Definition README (markdown format supported).
- `terraform_agent_pool_id` (String) The ID of the Terraform agent pool to use for running Terraform operations. This is only applicable when the execution mode is set to 'agent'.
- `terraform_cloud_workspace_details` (Attributes, Deprecated) Terraform Cloud Workspace details. If not provided, defaults to the HCP Terraform project of the associated application. (see [below for nested schema](#nestedatt--terraform_cloud_workspace_details))
- `terraform_execution_mode` (String) The execution mode of the HCP Terraform workspaces for add-ons using this add-on definition.
- `variable_options` (Attributes Set) List of variable options for the Add-on Definition. (see [below for nested schema](#nestedatt--variable_options))

### Read-Only

- `id` (String) The ID of the Add-on Definition.
- `organization_id` (String) The ID of the HCP organization where the Waypoint Add-on Definition is located.

<a id="nestedatt--terraform_cloud_workspace_details"></a>
### Nested Schema for `terraform_cloud_workspace_details`

Required:

- `name` (String) Name of the Terraform Cloud Project
- `terraform_project_id` (String) Terraform Cloud Project ID


<a id="nestedatt--variable_options"></a>
### Nested Schema for `variable_options`

Required:

- `name` (String) Variable name
- `options` (List of String) List of options
- `variable_type` (String) Variable type

Optional:

- `user_editable` (Boolean) Whether the variable is editable by the user creating an add-on. If options are provided, then the user may only use those options, regardless of this setting.




# hcp_waypoint_application `Resource`

-> **Note:** HCP Waypoint is currently in public beta.

The Waypoint Application resource managed the lifecycle of an Application that's based off of a Template.

<!-- schema generated by tfplugindocs -->
## Schema

### Required

- `name` (String) The name of the Application.
- `template_id` (String) ID of the Template this Application is based on.

### Optional

- `application_input_variables` (Attributes Set) Input variables set for the application. (see [below for nested schema](#nestedatt--application_input_variables))
- `project_id` (String) The ID of the HCP project where the Waypoint Application is located.
- `readme_markdown` (String) Instructions for using the Application (markdown format supported). Note: this is a base64 encoded string, and can only be set in configuration after initial creation. The initial version of the README is generated from the README Template from source Template.

### Read-Only

- `id` (String) The ID of the Application.
- `namespace_id` (String) Internal Namespace ID.
- `organization_id` (String) The ID of the HCP organization where the Waypoint Application is located.
- `output_values` (Attributes List) The output values, stored by HCP Waypoint, of the Terraform run for the Add-on, Sensitive values have type and value omitted. (see [below for nested schema](#nestedatt--output_values))
- `template_input_variables` (Attributes Set) Input variables set for the application. (see [below for nested schema](#nestedatt--template_input_variables))
- `template_name` (String) Name of the Template this Application is based on.

<a id="nestedatt--application_input_variables"></a>
### Nested Schema for `application_input_variables`

Required:

- `name` (String) Variable name
- `value` (String) Variable value
- `variable_type` (String) Variable type


<a id="nestedatt--output_values"></a>
### Nested Schema for `output_values`

Read-Only:

- `name` (String) The name of the output value.
- `sensitive` (Boolean) Whether the output value is Sensitive.
- `type` (String) The type of the output value.
- `value` (String) The value of the output value.


<a id="nestedatt--template_input_variables"></a>
### Nested Schema for `template_input_variables`

Required:

- `name` (String) Variable name
- `value` (String) Variable value

Optional:

- `variable_type` (String) Variable type




# hcp_waypoint_template `Resource`

-> **Note:** HCP Waypoint is currently in public beta.

Waypoint Template resource

## Example Usage

```terraform
resource "hcp_waypoint_template" "template" {
  name                            = "go-k8s-microservice"
  summary                         = "A simple Go microservice running on Kubernetes."
  description                     = <<EOF
This template deploys a simple Go microservice to Kubernetes. The microservice
is a simple HTTP server that listens on port 8080 and returns a JSON response.
The template includes a Dockerfile, Kubernetes manifests, and boiler plate code
for a gRPC service written in Go.
EOF
  terraform_project_id            = "prj-123456"
  labels                          = ["go", "kubernetes"]
  terraform_no_code_module_source = "private/fake-org/go-k8s-microservice/kubernetes"
  terraform_no_code_module_id     = "nocode-123456"
  variable_options = [
    {
      name          = "resource_size"
      user_editable = true
      options       = ["small", "medium", "large"]
    },
    {
      name          = "service_port"
      user_editable = false
      options       = ["8080"]
    },
  ]
}
```

<!-- schema generated by tfplugindocs -->
## Schema

### Required

- `name` (String) The name of the Template.
- `summary` (String) A brief description of the template, up to 110 characters.
- `terraform_no_code_module_id` (String) The ID of the Terraform no-code module to use for running Terraform operations. This is in the format of 'nocode-<ID>'.
- `terraform_no_code_module_source` (String) Terraform Cloud No-Code Module details
- `terraform_project_id` (String) The ID of the Terraform Cloud Project to create workspaces in. The ID is found on the Terraform Cloud Project settings page.

### Optional

- `description` (String) A description of the template, along with when and why it should be used, up to 500 characters
- `labels` (List of String) List of labels attached to this Template.
- `project_id` (String) The ID of the HCP project where the Waypoint Template is located.
- `readme_markdown_template` (String) Instructions for using the template (markdown format supported).
- `terraform_agent_pool_id` (String) The ID of the agent pool to use for Terraform operations, for workspaces created for applications using this template. Required if terraform_execution_mode is set to 'agent'.
- `terraform_cloud_workspace_details` (Attributes, Deprecated) Terraform Cloud Workspace details (see [below for nested schema](#nestedatt--terraform_cloud_workspace_details))
- `terraform_execution_mode` (String) The execution mode of the HCP Terraform workspaces created for applications using this template.
- `use_module_readme` (Boolean) If true, will auto-import the readme form the Terraform module used. If this is set to true, users should not also set `readme_markdown_template`.
- `variable_options` (Attributes Set) List of variable options for the template. (see [below for nested schema](#nestedatt--variable_options))

### Read-Only

- `id` (String) The ID of the Template.
- `organization_id` (String) The ID of the HCP organization where the Waypoint Template is located.

<a id="nestedatt--terraform_cloud_workspace_details"></a>
### Nested Schema for `terraform_cloud_workspace_details`

Required:

- `name` (String) Name of the Terraform Cloud Project
- `terraform_project_id` (String) Terraform Cloud Project ID


<a id="nestedatt--variable_options"></a>
### Nested Schema for `variable_options`

Required:

- `name` (String) Variable name
- `variable_type` (String) Variable type

Optional:

- `options` (List of String) List of options
- `user_editable` (Boolean) Whether the variable is editable by the user creating an application




# hcp_waypoint_tfc_config `Resource`

-> **Note:** HCP Waypoint is currently in public beta.

TFC Configuration used by Waypoint to administer TFC workspaces and applications.

## Example Usage

```terraform
resource "hcp_waypoint_tfc_config" "test" {
  token        = "token value"
  tfc_org_name = "example-tfc-org"
}
```

This resource can in conjunction with resources from the TFE provider to create
an appropriate Team level API token for use with configuring Waypoint:

```terraform
provider "tfe" {
  # see https://registry.terraform.io/providers/hashicorp/tfe/latest/docs
  # for more information on how to configure the TFE provider
}

data "tfe_team" "test" {
  name         = "example-team"
  organization = "example-tfc-org"
}

resource "tfe_team_token" "test" {
  team_id = data.tfe_team.test.id
}

resource "hcp_waypoint_tfc_config" "test" {
  token        = tfe_team_token.test.token
  tfc_org_name = data.tfe_team.test.organization
}
```

<!-- schema generated by tfplugindocs -->
## Schema

### Required

- `tfc_org_name` (String) The Terraform Cloud Organization with which the token is associated.
- `token` (String, Sensitive) Terraform Cloud team token. The token must include permissions to manage workspaces and applications.

### Optional

- `project_id` (String) Waypoint Project ID to associate with the TFC config

### Read-Only

- `id` (String) Internal identifier




# Authenticate with HCP

The HCP provider accepts two forms of authentication:

- client credentials, obtained on the creation of a service principal key
- user session, obtained via browser login (as of `v0.45.0`)

Only one form is needed.

## Client credentials

Client credentials are recommended for CI and local development with the SDK or any tool consuming it.

The `client_id` and `client_secret` must come from a service principal key. Service principals and service principal keys can be created in the HCP portal with an existing user account. The service principal must be authorized to access the API. Initially, it has no permissions, so the IAM policy must be updated to grant it permissions.

-> **Note:** The `client_secret` can only be obtained on creation of the service principal key; it is not stored anywhere after that.

Follow these steps to create service principal with the `contributor` role and a service principal key.

### 1. Create a service principal
-> **Note:** HCP has two types of Service Principals. Organization-Level Service Principals and Project-Level Service Principals. Either can be used with the HCP Terraform Provider. To read more about their differences please see our [documentation page](https://cloud.hashicorp.com/docs/hcp/admin/iam/service-principals).

Once you have registered and logged into the HCP portal, navigate to the Access Control (IAM) page. Select the Service Principals tab and create a new service principal. Give it the role Contributor, since it will be writing resources.

### 2. Create a service principal key

Once the service principal is created, navigate to its detail page by selecting its name in the list. Create a new service principal key.

-> **Note:** Save the client ID and secret returned on successful key creation. The client secret will not be available after creation.

Save the client ID and secret as the environment variables HCP_CLIENT_ID and HCP_CLIENT_SECRET.

Or, configure the provider with the client ID and secret by copy-pasting the values directly into provider config.
-> **Warning:** Hard-coded credentials are not recommended in Terraform configuration outside of local testing and risks secret exposure if committed to a code repository.

```terraform
// Credentials can be set explicitly or via the environment variables HCP_CLIENT_ID and HCP_CLIENT_SECRET
provider "hcp" {
  client_id     = "service-principal-key-client-id"
  client_secret = "service-principal-key-client-secret"
}
```
-> **Note:** If a [Project-Level Service Principal](https://cloud.hashicorp.com/docs/hcp/admin/iam/service-principals) is used, specify the default `project_id` in your provider configuration.

```bash
HCP_CLIENT_ID="..."
HCP_CLIENT_SECRET="..."
```

When client credentials are set, they are always used by the HCP Provider client, regardless of an existing user session.

## User session with browser login

After `v0.45.0`, the HCP Provider supports user session via browser login. User session is ideal for getting started or one-off usage. It works for local development, but will periodically prompt for re-authentication.

To obtain user credentials, the client credential environment variables `HCP_CLIENT_ID` and `HCP_CLIENT_SECRET` **must be unset.**

Upon running `terraform apply` or `terraform plan`, your web browser will navigate to the HCP portal, where you will be prompted to login. Once logged in, you may create new or manage existing resources fully authenticated. Your session will last 24 hours before prompting you to reauthenticate.

```terraform
// If no credentials are set, a user session can be obtained through browser login.
provider "hcp" {}
```
